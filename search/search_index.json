{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"Mozilla Public License Version 2.0 \u00b6 1. Definitions \u00b6 1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions \u00b6 2.1. Grants \u00b6 Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date \u00b6 The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope \u00b6 The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses \u00b6 No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation \u00b6 Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use \u00b6 This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions \u00b6 Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities \u00b6 3.1. Distribution of Source Form \u00b6 All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form \u00b6 If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work \u00b6 You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices \u00b6 You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms \u00b6 You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation \u00b6 If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination \u00b6 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. 6. Disclaimer of Warranty \u00b6 Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer. 7. Limitation of Liability \u00b6 Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You. 8. Litigation \u00b6 Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous \u00b6 This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License \u00b6 10.1. New Versions \u00b6 Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions \u00b6 You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions \u00b6 If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses \u00b6 If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice \u00b6 This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice \u00b6 This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"license/#1-definitions","text":"1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"license/#2-license-grants-and-conditions","text":"","title":"2. License Grants and Conditions"},{"location":"license/#21-grants","text":"Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.","title":"2.1. Grants"},{"location":"license/#22-effective-date","text":"The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.","title":"2.2. Effective Date"},{"location":"license/#23-limitations-on-grant-scope","text":"The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).","title":"2.3. Limitations on Grant Scope"},{"location":"license/#24-subsequent-licenses","text":"No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).","title":"2.4. Subsequent Licenses"},{"location":"license/#25-representation","text":"Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.","title":"2.5. Representation"},{"location":"license/#26-fair-use","text":"This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.","title":"2.6. Fair Use"},{"location":"license/#27-conditions","text":"Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2.7. Conditions"},{"location":"license/#3-responsibilities","text":"","title":"3. Responsibilities"},{"location":"license/#31-distribution-of-source-form","text":"All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.","title":"3.1. Distribution of Source Form"},{"location":"license/#32-distribution-of-executable-form","text":"If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License.","title":"3.2. Distribution of Executable Form"},{"location":"license/#33-distribution-of-a-larger-work","text":"You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).","title":"3.3. Distribution of a Larger Work"},{"location":"license/#34-notices","text":"You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.","title":"3.4. Notices"},{"location":"license/#35-application-of-additional-terms","text":"You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3.5. Application of Additional Terms"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.","title":"5. Termination"},{"location":"license/#6-disclaimer-of-warranty","text":"Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.","title":"6. Disclaimer of Warranty"},{"location":"license/#7-limitation-of-liability","text":"Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.","title":"7. Limitation of Liability"},{"location":"license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"license/#10-versions-of-the-license","text":"","title":"10. Versions of the License"},{"location":"license/#101-new-versions","text":"Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.","title":"10.1. New Versions"},{"location":"license/#102-effect-of-new-versions","text":"You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.","title":"10.2. Effect of New Versions"},{"location":"license/#103-modified-versions","text":"If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).","title":"10.3. Modified Versions"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","text":"If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses"},{"location":"license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice"},{"location":"api/","text":"MUD Protocols API \u00b6 Automatically generated API reference. MUD Protocols \u00b6 Connection Charset Protocol Protocol Manager MUD Client Compression Protocol MUME Protocol Initiator Telnet Protocol MUME XML Protocol","title":"API Index"},{"location":"api/#mud-protocols-api","text":"Automatically generated API reference.","title":"MUD Protocols API"},{"location":"api/#mud-protocols","text":"Connection Charset Protocol Protocol Manager MUD Client Compression Protocol MUME Protocol Initiator Telnet Protocol MUME XML Protocol","title":"MUD Protocols"},{"location":"api/charset/","text":"Module mudproto.charset \u00b6 Charset protocol. Class CharsetMixIn( TelnetInterface ) \u00b6 A charset mix in class for the Telnet protocol. Source code in mudproto/charset.py class CharsetMixIn ( TelnetInterface ): \"\"\"A charset mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] @property def charset ( self ) -> str : \"\"\"The currently used character set.\"\"\" return str ( self . _charset , \"us-ascii\" ) def negotiate_charset ( self , name : Union [ bytes , str ]) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" if not isinstance ( name , str ): name = str ( name , \"us-ascii\" ) try : target = codecs . lookup ( name ) . name except LookupError : logger . warning ( f \"' { name } ' not a valid codec\" ) return for item in self . _charsets : if target == codecs . lookup ( str ( item , \"us-ascii\" )) . name : logger . debug ( f \"Tell peer we would like to use the { item !r} charset.\" ) self . request_negotiation ( CHARSET , CHARSET_REQUEST + separator + item ) return logger . warning ( f \"Could not find any charsets which target ' { target } '\" ) @staticmethod def parse_supported_charsets ( response : bytes ) -> tuple [ bytes , ... ]: \"\"\" Parses the supported character sets from peer. Args: response: The response from peer, containing the supported character sets. Returns: The character sets supported by peer, with duplicate aliases removed. \"\"\" charsets : list [ bytes ] = [] names : set [ str ] = set () separator , response = response [: 1 ], response [ 1 :] for item in response . split ( separator ): with suppress ( LookupError ): name = codecs . lookup ( str ( item , \"us-ascii\" )) . name if name not in names : charsets . append ( item ) names . add ( name ) return tuple ( charsets ) def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : self . _charsets = self . parse_supported_charsets ( response ) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiate_charset ( self . _charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . _charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enable_local ( option )) # pragma: no cover def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return super () . on_disable_local ( option ) # type: ignore[safe-super] # pragma: no cover Attribute charset : str property readonly \u00b6 The currently used character set. Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , * args , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/charset.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/charset.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/charset.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method get_option_state ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/charset.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method negotiate_charset ( self , name ) \u00b6 Negotiates changing the character set. Parameters: Name Type Description Default name Union[bytes, str] The name of the character set to use. required Source code in mudproto/charset.py def negotiate_charset ( self , name : Union [ bytes , str ]) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" if not isinstance ( name , str ): name = str ( name , \"us-ascii\" ) try : target = codecs . lookup ( name ) . name except LookupError : logger . warning ( f \"' { name } ' not a valid codec\" ) return for item in self . _charsets : if target == codecs . lookup ( str ( item , \"us-ascii\" )) . name : logger . debug ( f \"Tell peer we would like to use the { item !r} charset.\" ) self . request_negotiation ( CHARSET , CHARSET_REQUEST + separator + item ) return logger . warning ( f \"Could not find any charsets which target ' { target } '\" ) Method on_charset ( self , data ) \u00b6 Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mudproto/charset.py def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : self . _charsets = self . parse_supported_charsets ( response ) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiate_charset ( self . _charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . _charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connection_lost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/charset.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connection_made ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/charset.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_data_received ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/charset.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data ) Method on_disable_local ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return super () . on_disable_local ( option ) # type: ignore[safe-super] # pragma: no cover Method on_disable_remote ( self , option ) inherited \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) Method on_enable_local ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/charset.py def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enable_local ( option )) # pragma: no cover Method on_enable_remote ( self , option ) inherited \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/charset.py @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default. Method on_option_enabled ( self , option ) inherited \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/charset.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandled_command ( self , command , option ) inherited \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandled_subnegotiation ( self , option , data ) inherited \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method parse_supported_charsets ( response ) staticmethod \u00b6 Parses the supported character sets from peer. Parameters: Name Type Description Default response bytes The response from peer, containing the supported character sets. required Returns: Type Description tuple[bytes, ...] The character sets supported by peer, with duplicate aliases removed. Source code in mudproto/charset.py @staticmethod def parse_supported_charsets ( response : bytes ) -> tuple [ bytes , ... ]: \"\"\" Parses the supported character sets from peer. Args: response: The response from peer, containing the supported character sets. Returns: The character sets supported by peer, with duplicate aliases removed. \"\"\" charsets : list [ bytes ] = [] names : set [ str ] = set () separator , response = response [: 1 ], response [ 1 :] for item in response . split ( separator ): with suppress ( LookupError ): name = codecs . lookup ( str ( item , \"us-ascii\" )) . name if name not in names : charsets . append ( item ) names . add ( name ) return tuple ( charsets ) Method request_negotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/charset.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/charset.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/charset.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"charset.py"},{"location":"api/charset/#mudproto.charset","text":"Charset protocol.","title":"charset"},{"location":"api/charset/#mudproto.charset.CharsetMixIn","text":"A charset mix in class for the Telnet protocol. Source code in mudproto/charset.py class CharsetMixIn ( TelnetInterface ): \"\"\"A charset mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] @property def charset ( self ) -> str : \"\"\"The currently used character set.\"\"\" return str ( self . _charset , \"us-ascii\" ) def negotiate_charset ( self , name : Union [ bytes , str ]) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" if not isinstance ( name , str ): name = str ( name , \"us-ascii\" ) try : target = codecs . lookup ( name ) . name except LookupError : logger . warning ( f \"' { name } ' not a valid codec\" ) return for item in self . _charsets : if target == codecs . lookup ( str ( item , \"us-ascii\" )) . name : logger . debug ( f \"Tell peer we would like to use the { item !r} charset.\" ) self . request_negotiation ( CHARSET , CHARSET_REQUEST + separator + item ) return logger . warning ( f \"Could not find any charsets which target ' { target } '\" ) @staticmethod def parse_supported_charsets ( response : bytes ) -> tuple [ bytes , ... ]: \"\"\" Parses the supported character sets from peer. Args: response: The response from peer, containing the supported character sets. Returns: The character sets supported by peer, with duplicate aliases removed. \"\"\" charsets : list [ bytes ] = [] names : set [ str ] = set () separator , response = response [: 1 ], response [ 1 :] for item in response . split ( separator ): with suppress ( LookupError ): name = codecs . lookup ( str ( item , \"us-ascii\" )) . name if name not in names : charsets . append ( item ) names . add ( name ) return tuple ( charsets ) def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : self . _charsets = self . parse_supported_charsets ( response ) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiate_charset ( self . _charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . _charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enable_local ( option )) # pragma: no cover def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return super () . on_disable_local ( option ) # type: ignore[safe-super] # pragma: no cover","title":"CharsetMixIn"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.charset","text":"The currently used character set.","title":"charset"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.__init__","text":"Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/charset.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ]","title":"__init__()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/charset.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/charset.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.get_option_state","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/charset.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"get_option_state()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.negotiate_charset","text":"Negotiates changing the character set. Parameters: Name Type Description Default name Union[bytes, str] The name of the character set to use. required Source code in mudproto/charset.py def negotiate_charset ( self , name : Union [ bytes , str ]) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" if not isinstance ( name , str ): name = str ( name , \"us-ascii\" ) try : target = codecs . lookup ( name ) . name except LookupError : logger . warning ( f \"' { name } ' not a valid codec\" ) return for item in self . _charsets : if target == codecs . lookup ( str ( item , \"us-ascii\" )) . name : logger . debug ( f \"Tell peer we would like to use the { item !r} charset.\" ) self . request_negotiation ( CHARSET , CHARSET_REQUEST + separator + item ) return logger . warning ( f \"Could not find any charsets which target ' { target } '\" )","title":"negotiate_charset()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_charset","text":"Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mudproto/charset.py def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : self . _charsets = self . parse_supported_charsets ( response ) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiate_charset ( self . _charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . _charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET )","title":"on_charset()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/charset.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connection_lost()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/charset.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connection_made()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/charset.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data )","title":"on_data_received()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_disable_local","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return super () . on_disable_local ( option ) # type: ignore[safe-super] # pragma: no cover","title":"on_disable_local()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_disable_remote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" )","title":"on_disable_remote()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_enable_local","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/charset.py def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enable_local ( option )) # pragma: no cover","title":"on_enable_local()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_enable_remote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/charset.py @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default.","title":"on_enable_remote()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_option_enabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/charset.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_option_enabled()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_unhandled_command","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandled_command()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_unhandled_subnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandled_subnegotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.parse_supported_charsets","text":"Parses the supported character sets from peer. Parameters: Name Type Description Default response bytes The response from peer, containing the supported character sets. required Returns: Type Description tuple[bytes, ...] The character sets supported by peer, with duplicate aliases removed. Source code in mudproto/charset.py @staticmethod def parse_supported_charsets ( response : bytes ) -> tuple [ bytes , ... ]: \"\"\" Parses the supported character sets from peer. Args: response: The response from peer, containing the supported character sets. Returns: The character sets supported by peer, with duplicate aliases removed. \"\"\" charsets : list [ bytes ] = [] names : set [ str ] = set () separator , response = response [: 1 ], response [ 1 :] for item in response . split ( separator ): with suppress ( LookupError ): name = codecs . lookup ( str ( item , \"us-ascii\" )) . name if name not in names : charsets . append ( item ) names . add ( name ) return tuple ( charsets )","title":"parse_supported_charsets()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.request_negotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"request_negotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/charset.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/charset.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/charset.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/connection/","text":"Module mudproto.connection \u00b6 MUD connection. Class ConnectionInterface( ABC ) \u00b6 Input and output to a MUD client or server. Source code in mudproto/connection.py class ConnectionInterface ( ABC ): \"\"\"Input and output to a MUD client or server.\"\"\" def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. **kwargs: Key-word only arguments (currently unused). \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client @property def is_client ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _is_client @property def is_server ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _is_client def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data ) Attribute is_client : bool property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , writer , receiver , * , is_client , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default writer ConnectionWriterType The object where output is written. required receiver ConnectionReceiverType The object where input is received. required is_client bool True if acting as a client, False if acting as a server. required **kwargs Any Key-word only arguments (currently unused). {} Source code in mudproto/connection.py def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. **kwargs: Key-word only arguments (currently unused). \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client Method on_connection_lost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/connection.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connection_made ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/connection.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_data_received ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/connection.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data ) Method write ( self , data ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/connection.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"connection.py"},{"location":"api/connection/#mudproto.connection","text":"MUD connection.","title":"connection"},{"location":"api/connection/#mudproto.connection.ConnectionInterface","text":"Input and output to a MUD client or server. Source code in mudproto/connection.py class ConnectionInterface ( ABC ): \"\"\"Input and output to a MUD client or server.\"\"\" def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. **kwargs: Key-word only arguments (currently unused). \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client @property def is_client ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _is_client @property def is_server ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _is_client def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data )","title":"ConnectionInterface"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.__init__","text":"Defines the constructor. Parameters: Name Type Description Default writer ConnectionWriterType The object where output is written. required receiver ConnectionReceiverType The object where input is received. required is_client bool True if acting as a client, False if acting as a server. required **kwargs Any Key-word only arguments (currently unused). {} Source code in mudproto/connection.py def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. **kwargs: Key-word only arguments (currently unused). \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client","title":"__init__()"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/connection.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connection_lost()"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/connection.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connection_made()"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/connection.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data )","title":"on_data_received()"},{"location":"api/connection/#mudproto.connection.ConnectionInterface.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/connection.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/manager/","text":"Module mudproto.manager \u00b6 Protocol manager. Class Manager \u00b6 Handles registering and unregistering protocol classes to a connection. Source code in mudproto/manager.py class Manager : \"\"\"Handles registering and unregistering protocol classes to a connection.\"\"\" def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , prompt_terminator : Optional [ bytes ] = None , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. prompt_terminator: The byte sequence used to terminate a prompt. If None, IAC + GA is used. \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client self . prompt_terminator : bytes if prompt_terminator is None : self . prompt_terminator = IAC + GA else : self . prompt_terminator = ( prompt_terminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _read_buffer : bytearray = bytearray () self . _write_buffer : bytearray = bytearray () self . _handlers : list [ ConnectionInterface ] = [] self . _is_connected : bool = False @property def is_client ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _is_client @property def is_server ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _is_client @property def is_connected ( self ) -> bool : \"\"\"Connection status.\"\"\" return self . _is_connected def __enter__ ( self ) -> Self : self . connect () return self def __exit__ ( self , exc_type : Optional [ type [ BaseException ]], exc_value : Optional [ BaseException ], exc_traceback : Optional [ TracebackType ], ) -> None : self . disconnect () def __del__ ( self ) -> None : self . disconnect () def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . is_connected : self . _is_connected = True if self . _read_buffer : data = bytes ( self . _read_buffer ) self . _read_buffer . clear () self . parse ( data ) if self . _write_buffer : data = bytes ( self . _write_buffer ) self . _write_buffer . clear () self . write ( data ) def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . is_connected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _is_connected = False def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . is_connected or not self . _handlers : self . _read_buffer . extend ( data ) return if self . _read_buffer : data = bytes ( self . _read_buffer + data ) self . _read_buffer . clear () if data : self . _handlers [ 0 ] . on_data_received ( data ) def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escape_iac ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . prompt_terminator if not self . is_connected or not self . _handlers : self . _write_buffer . extend ( data ) return if self . _write_buffer : data = bytes ( self . _write_buffer + data ) self . _write_buffer . clear () if data : self . _writer ( data ) def register ( self , handler : type [ ConnectionInterface ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. Raises: TypeError: Handler is an instance instead of a class. ValueError: Handler was already registered. \"\"\" if not inspect . isclass ( handler ): raise TypeError ( \"Class required, not instance.\" ) if any ( i for i in self . _handlers if isinstance ( i , handler )): raise ValueError ( \"Already registered.\" ) instance : ConnectionInterface = handler ( self . write , self . _receiver , is_client = self . _is_client , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_data_received # NOQA: SLF001 self . _handlers . append ( instance ) instance . on_connection_made () def unregister ( self , instance : ConnectionInterface ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. Raises: TypeError: Handler is a class instead of an instance. ValueError: Handler was never registered. \"\"\" if inspect . isclass ( instance ): raise TypeError ( \"Instance required, not class.\" ) if instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver # NOQA: SLF001 instance . on_connection_lost () Attribute is_client : bool property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_connected : bool property readonly \u00b6 Connection status. Attribute is_server : bool property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , writer , receiver , * , is_client , prompt_terminator = None ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default writer ConnectionWriterType The object where output is written. required receiver ConnectionReceiverType The object where input is received. required is_client bool True if acting as a client, False if acting as a server. required prompt_terminator Optional[bytes] The byte sequence used to terminate a prompt. If None, IAC + GA is used. None Source code in mudproto/manager.py def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , prompt_terminator : Optional [ bytes ] = None , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. prompt_terminator: The byte sequence used to terminate a prompt. If None, IAC + GA is used. \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client self . prompt_terminator : bytes if prompt_terminator is None : self . prompt_terminator = IAC + GA else : self . prompt_terminator = ( prompt_terminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _read_buffer : bytearray = bytearray () self . _write_buffer : bytearray = bytearray () self . _handlers : list [ ConnectionInterface ] = [] self . _is_connected : bool = False Method close ( self ) \u00b6 Calls disconnect . Source code in mudproto/manager.py def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () Method connect ( self ) \u00b6 Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mudproto/manager.py def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . is_connected : self . _is_connected = True if self . _read_buffer : data = bytes ( self . _read_buffer ) self . _read_buffer . clear () self . parse ( data ) if self . _write_buffer : data = bytes ( self . _write_buffer ) self . _write_buffer . clear () self . write ( data ) Method disconnect ( self ) \u00b6 Signals that peer has disconnected. Source code in mudproto/manager.py def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . is_connected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _is_connected = False Method parse ( self , data ) \u00b6 Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mudproto/manager.py def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . is_connected or not self . _handlers : self . _read_buffer . extend ( data ) return if self . _read_buffer : data = bytes ( self . _read_buffer + data ) self . _read_buffer . clear () if data : self . _handlers [ 0 ] . on_data_received ( data ) Method register ( self , handler , ** kwargs ) \u00b6 Registers a protocol handler. Parameters: Name Type Description Default handler type[ConnectionInterface] The handler to be registered. required **kwargs Any Key word arguments to be passed to the handler's constructer. {} Exceptions: Type Description TypeError Handler is an instance instead of a class. ValueError Handler was already registered. Source code in mudproto/manager.py def register ( self , handler : type [ ConnectionInterface ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. Raises: TypeError: Handler is an instance instead of a class. ValueError: Handler was already registered. \"\"\" if not inspect . isclass ( handler ): raise TypeError ( \"Class required, not instance.\" ) if any ( i for i in self . _handlers if isinstance ( i , handler )): raise ValueError ( \"Already registered.\" ) instance : ConnectionInterface = handler ( self . write , self . _receiver , is_client = self . _is_client , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_data_received # NOQA: SLF001 self . _handlers . append ( instance ) instance . on_connection_made () Method unregister ( self , instance ) \u00b6 Unregisters a protocol handler. Parameters: Name Type Description Default instance ConnectionInterface The handler instance to be unregistered. required Exceptions: Type Description TypeError Handler is a class instead of an instance. ValueError Handler was never registered. Source code in mudproto/manager.py def unregister ( self , instance : ConnectionInterface ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. Raises: TypeError: Handler is a class instead of an instance. ValueError: Handler was never registered. \"\"\" if inspect . isclass ( instance ): raise TypeError ( \"Instance required, not class.\" ) if instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver # NOQA: SLF001 instance . on_connection_lost () Method write ( self , data , * , escape = False , prompt = False ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If True, escapes line endings and IAC characters. False prompt bool If True, appends the prompt terminator to the data. False Source code in mudproto/manager.py def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escape_iac ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . prompt_terminator if not self . is_connected or not self . _handlers : self . _write_buffer . extend ( data ) return if self . _write_buffer : data = bytes ( self . _write_buffer + data ) self . _write_buffer . clear () if data : self . _writer ( data )","title":"manager.py"},{"location":"api/manager/#mudproto.manager","text":"Protocol manager.","title":"manager"},{"location":"api/manager/#mudproto.manager.Manager","text":"Handles registering and unregistering protocol classes to a connection. Source code in mudproto/manager.py class Manager : \"\"\"Handles registering and unregistering protocol classes to a connection.\"\"\" def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , prompt_terminator : Optional [ bytes ] = None , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. prompt_terminator: The byte sequence used to terminate a prompt. If None, IAC + GA is used. \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client self . prompt_terminator : bytes if prompt_terminator is None : self . prompt_terminator = IAC + GA else : self . prompt_terminator = ( prompt_terminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _read_buffer : bytearray = bytearray () self . _write_buffer : bytearray = bytearray () self . _handlers : list [ ConnectionInterface ] = [] self . _is_connected : bool = False @property def is_client ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _is_client @property def is_server ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _is_client @property def is_connected ( self ) -> bool : \"\"\"Connection status.\"\"\" return self . _is_connected def __enter__ ( self ) -> Self : self . connect () return self def __exit__ ( self , exc_type : Optional [ type [ BaseException ]], exc_value : Optional [ BaseException ], exc_traceback : Optional [ TracebackType ], ) -> None : self . disconnect () def __del__ ( self ) -> None : self . disconnect () def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . is_connected : self . _is_connected = True if self . _read_buffer : data = bytes ( self . _read_buffer ) self . _read_buffer . clear () self . parse ( data ) if self . _write_buffer : data = bytes ( self . _write_buffer ) self . _write_buffer . clear () self . write ( data ) def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . is_connected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _is_connected = False def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . is_connected or not self . _handlers : self . _read_buffer . extend ( data ) return if self . _read_buffer : data = bytes ( self . _read_buffer + data ) self . _read_buffer . clear () if data : self . _handlers [ 0 ] . on_data_received ( data ) def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escape_iac ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . prompt_terminator if not self . is_connected or not self . _handlers : self . _write_buffer . extend ( data ) return if self . _write_buffer : data = bytes ( self . _write_buffer + data ) self . _write_buffer . clear () if data : self . _writer ( data ) def register ( self , handler : type [ ConnectionInterface ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. Raises: TypeError: Handler is an instance instead of a class. ValueError: Handler was already registered. \"\"\" if not inspect . isclass ( handler ): raise TypeError ( \"Class required, not instance.\" ) if any ( i for i in self . _handlers if isinstance ( i , handler )): raise ValueError ( \"Already registered.\" ) instance : ConnectionInterface = handler ( self . write , self . _receiver , is_client = self . _is_client , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_data_received # NOQA: SLF001 self . _handlers . append ( instance ) instance . on_connection_made () def unregister ( self , instance : ConnectionInterface ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. Raises: TypeError: Handler is a class instead of an instance. ValueError: Handler was never registered. \"\"\" if inspect . isclass ( instance ): raise TypeError ( \"Instance required, not class.\" ) if instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver # NOQA: SLF001 instance . on_connection_lost ()","title":"Manager"},{"location":"api/manager/#mudproto.manager.Manager.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/manager/#mudproto.manager.Manager.is_connected","text":"Connection status.","title":"is_connected"},{"location":"api/manager/#mudproto.manager.Manager.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/manager/#mudproto.manager.Manager.__init__","text":"Defines the constructor. Parameters: Name Type Description Default writer ConnectionWriterType The object where output is written. required receiver ConnectionReceiverType The object where input is received. required is_client bool True if acting as a client, False if acting as a server. required prompt_terminator Optional[bytes] The byte sequence used to terminate a prompt. If None, IAC + GA is used. None Source code in mudproto/manager.py def __init__ ( self , writer : ConnectionWriterType , receiver : ConnectionReceiverType , * , is_client : bool , prompt_terminator : Optional [ bytes ] = None , ) -> None : \"\"\" Defines the constructor. Args: writer: The object where output is written. receiver: The object where input is received. is_client: True if acting as a client, False if acting as a server. prompt_terminator: The byte sequence used to terminate a prompt. If None, IAC + GA is used. \"\"\" self . _writer : ConnectionWriterType = writer self . _receiver : ConnectionReceiverType = receiver self . _is_client : bool = is_client self . prompt_terminator : bytes if prompt_terminator is None : self . prompt_terminator = IAC + GA else : self . prompt_terminator = ( prompt_terminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _read_buffer : bytearray = bytearray () self . _write_buffer : bytearray = bytearray () self . _handlers : list [ ConnectionInterface ] = [] self . _is_connected : bool = False","title":"__init__()"},{"location":"api/manager/#mudproto.manager.Manager.close","text":"Calls disconnect . Source code in mudproto/manager.py def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect ()","title":"close()"},{"location":"api/manager/#mudproto.manager.Manager.connect","text":"Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mudproto/manager.py def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . is_connected : self . _is_connected = True if self . _read_buffer : data = bytes ( self . _read_buffer ) self . _read_buffer . clear () self . parse ( data ) if self . _write_buffer : data = bytes ( self . _write_buffer ) self . _write_buffer . clear () self . write ( data )","title":"connect()"},{"location":"api/manager/#mudproto.manager.Manager.disconnect","text":"Signals that peer has disconnected. Source code in mudproto/manager.py def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . is_connected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _is_connected = False","title":"disconnect()"},{"location":"api/manager/#mudproto.manager.Manager.parse","text":"Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mudproto/manager.py def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . is_connected or not self . _handlers : self . _read_buffer . extend ( data ) return if self . _read_buffer : data = bytes ( self . _read_buffer + data ) self . _read_buffer . clear () if data : self . _handlers [ 0 ] . on_data_received ( data )","title":"parse()"},{"location":"api/manager/#mudproto.manager.Manager.register","text":"Registers a protocol handler. Parameters: Name Type Description Default handler type[ConnectionInterface] The handler to be registered. required **kwargs Any Key word arguments to be passed to the handler's constructer. {} Exceptions: Type Description TypeError Handler is an instance instead of a class. ValueError Handler was already registered. Source code in mudproto/manager.py def register ( self , handler : type [ ConnectionInterface ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. Raises: TypeError: Handler is an instance instead of a class. ValueError: Handler was already registered. \"\"\" if not inspect . isclass ( handler ): raise TypeError ( \"Class required, not instance.\" ) if any ( i for i in self . _handlers if isinstance ( i , handler )): raise ValueError ( \"Already registered.\" ) instance : ConnectionInterface = handler ( self . write , self . _receiver , is_client = self . _is_client , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_data_received # NOQA: SLF001 self . _handlers . append ( instance ) instance . on_connection_made ()","title":"register()"},{"location":"api/manager/#mudproto.manager.Manager.unregister","text":"Unregisters a protocol handler. Parameters: Name Type Description Default instance ConnectionInterface The handler instance to be unregistered. required Exceptions: Type Description TypeError Handler is a class instead of an instance. ValueError Handler was never registered. Source code in mudproto/manager.py def unregister ( self , instance : ConnectionInterface ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. Raises: TypeError: Handler is a class instead of an instance. ValueError: Handler was never registered. \"\"\" if inspect . isclass ( instance ): raise TypeError ( \"Instance required, not class.\" ) if instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver # NOQA: SLF001 instance . on_connection_lost ()","title":"unregister()"},{"location":"api/manager/#mudproto.manager.Manager.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If True, escapes line endings and IAC characters. False prompt bool If True, appends the prompt terminator to the data. False Source code in mudproto/manager.py def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escape_iac ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . prompt_terminator if not self . is_connected or not self . _handlers : self . _write_buffer . extend ( data ) return if self . _write_buffer : data = bytes ( self . _write_buffer + data ) self . _write_buffer . clear () if data : self . _writer ( data )","title":"write()"},{"location":"api/mccp/","text":"Module mudproto.mccp \u00b6 MUD Client Compression protocol. Class MCCPMixIn( TelnetInterface ) \u00b6 An MCCP mix in class for the Telnet protocol. Source code in mudproto/mccp.py class MCCPMixIn ( TelnetInterface ): \"\"\"An MCCP mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ MCCP1 ] = lambda * args : None self . subnegotiation_map [ MCCP2 ] = lambda * args : None self . _compression_enabled : bool = False self . _mccp_version : Union [ int , None ] = None self . _compressed_input_buffer : bytearray = bytearray () self . _decompressor : Any = None def disable_mccp ( self ) -> None : \"\"\"Disables compression.\"\"\" self . _mccp_version = None self . _compression_enabled = False self . _decompressor = None def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 input_buffer : bytearray = self . _compressed_input_buffer input_buffer . extend ( data ) while input_buffer : if self . _compression_enabled : # Data is compressed. super () . on_data_received ( self . _decompressor . decompress ( input_buffer )) input_buffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data. # Likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) input_buffer . extend ( self . _decompressor . unused_data ) state = self . get_option_state ( MCCP1 if self . _mccp_version == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disable_mccp () continue # Process the remaining uncompressed data. return # input_buffer is empty, no need to loop again. # Data is uncompressed. iac_index : int = input_buffer . find ( IAC ) if self . _mccp_version is not None and iac_index != - 1 : # MCCP was negotiated on, and an IAC byte was found. if iac_index > 0 : super () . on_data_received ( bytes ( input_buffer [: iac_index ])) del input_buffer [: iac_index ] if input_buffer == IAC : # Partial IAC sequence. return if input_buffer . startswith ( IAC_SB ): se_index : int = input_buffer . find ( SE ) if se_index == - 1 : # Partial subnegotiation sequence. return if input_buffer . startswith ( MCCP_ENABLED_RESPONSES ): # The server enabled compression. Subsequent data will be compressed. self . _compression_enabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_data_received ( bytes ( input_buffer [: se_index + 1 ])) del input_buffer [: se_index + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_data_received ( bytes ( input_buffer [: 2 ])) del input_buffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_data_received ( bytes ( input_buffer )) input_buffer . clear () def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 if option in { MCCP1 , MCCP2 }: if self . _mccp_version is None : self . _mccp_version = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccp_version } negotiation enabled.\" ) return True return False return bool ( super () . on_enable_remote ( option )) # pragma: no cover def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 if option in { MCCP1 , MCCP2 }: logger . debug ( f \"MCCP { self . _mccp_version if self . _mccp_version is not None else '' } negotiation disabled.\" ) self . disable_mccp () return super () . on_disable_remote ( option ) # type: ignore[safe-super] # pragma: no cover Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , * args , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/mccp.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ MCCP1 ] = lambda * args : None self . subnegotiation_map [ MCCP2 ] = lambda * args : None self . _compression_enabled : bool = False self . _mccp_version : Union [ int , None ] = None self . _compressed_input_buffer : bytearray = bytearray () self . _decompressor : Any = None Method disable_mccp ( self ) \u00b6 Disables compression. Source code in mudproto/mccp.py def disable_mccp ( self ) -> None : \"\"\"Disables compression.\"\"\" self . _mccp_version = None self . _compression_enabled = False self . _decompressor = None Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/mccp.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/mccp.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method get_option_state ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/mccp.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connection_lost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/mccp.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connection_made ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/mccp.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_data_received ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mccp.py def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 input_buffer : bytearray = self . _compressed_input_buffer input_buffer . extend ( data ) while input_buffer : if self . _compression_enabled : # Data is compressed. super () . on_data_received ( self . _decompressor . decompress ( input_buffer )) input_buffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data. # Likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) input_buffer . extend ( self . _decompressor . unused_data ) state = self . get_option_state ( MCCP1 if self . _mccp_version == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disable_mccp () continue # Process the remaining uncompressed data. return # input_buffer is empty, no need to loop again. # Data is uncompressed. iac_index : int = input_buffer . find ( IAC ) if self . _mccp_version is not None and iac_index != - 1 : # MCCP was negotiated on, and an IAC byte was found. if iac_index > 0 : super () . on_data_received ( bytes ( input_buffer [: iac_index ])) del input_buffer [: iac_index ] if input_buffer == IAC : # Partial IAC sequence. return if input_buffer . startswith ( IAC_SB ): se_index : int = input_buffer . find ( SE ) if se_index == - 1 : # Partial subnegotiation sequence. return if input_buffer . startswith ( MCCP_ENABLED_RESPONSES ): # The server enabled compression. Subsequent data will be compressed. self . _compression_enabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_data_received ( bytes ( input_buffer [: se_index + 1 ])) del input_buffer [: se_index + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_data_received ( bytes ( input_buffer [: 2 ])) del input_buffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_data_received ( bytes ( input_buffer )) input_buffer . clear () Method on_disable_local ( self , option ) inherited \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disable_remote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 if option in { MCCP1 , MCCP2 }: logger . debug ( f \"MCCP { self . _mccp_version if self . _mccp_version is not None else '' } negotiation disabled.\" ) self . disable_mccp () return super () . on_disable_remote ( option ) # type: ignore[safe-super] # pragma: no cover Method on_enable_local ( self , option ) inherited \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/mccp.py @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default. Method on_enable_remote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/mccp.py def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 if option in { MCCP1 , MCCP2 }: if self . _mccp_version is None : self . _mccp_version = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccp_version } negotiation enabled.\" ) return True return False return bool ( super () . on_enable_remote ( option )) # pragma: no cover Method on_option_enabled ( self , option ) inherited \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/mccp.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandled_command ( self , command , option ) inherited \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandled_subnegotiation ( self , option , data ) inherited \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method request_negotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/mccp.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/mccp.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mccp.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"mccp.py"},{"location":"api/mccp/#mudproto.mccp","text":"MUD Client Compression protocol.","title":"mccp"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn","text":"An MCCP mix in class for the Telnet protocol. Source code in mudproto/mccp.py class MCCPMixIn ( TelnetInterface ): \"\"\"An MCCP mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ MCCP1 ] = lambda * args : None self . subnegotiation_map [ MCCP2 ] = lambda * args : None self . _compression_enabled : bool = False self . _mccp_version : Union [ int , None ] = None self . _compressed_input_buffer : bytearray = bytearray () self . _decompressor : Any = None def disable_mccp ( self ) -> None : \"\"\"Disables compression.\"\"\" self . _mccp_version = None self . _compression_enabled = False self . _decompressor = None def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 input_buffer : bytearray = self . _compressed_input_buffer input_buffer . extend ( data ) while input_buffer : if self . _compression_enabled : # Data is compressed. super () . on_data_received ( self . _decompressor . decompress ( input_buffer )) input_buffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data. # Likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) input_buffer . extend ( self . _decompressor . unused_data ) state = self . get_option_state ( MCCP1 if self . _mccp_version == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disable_mccp () continue # Process the remaining uncompressed data. return # input_buffer is empty, no need to loop again. # Data is uncompressed. iac_index : int = input_buffer . find ( IAC ) if self . _mccp_version is not None and iac_index != - 1 : # MCCP was negotiated on, and an IAC byte was found. if iac_index > 0 : super () . on_data_received ( bytes ( input_buffer [: iac_index ])) del input_buffer [: iac_index ] if input_buffer == IAC : # Partial IAC sequence. return if input_buffer . startswith ( IAC_SB ): se_index : int = input_buffer . find ( SE ) if se_index == - 1 : # Partial subnegotiation sequence. return if input_buffer . startswith ( MCCP_ENABLED_RESPONSES ): # The server enabled compression. Subsequent data will be compressed. self . _compression_enabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_data_received ( bytes ( input_buffer [: se_index + 1 ])) del input_buffer [: se_index + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_data_received ( bytes ( input_buffer [: 2 ])) del input_buffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_data_received ( bytes ( input_buffer )) input_buffer . clear () def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 if option in { MCCP1 , MCCP2 }: if self . _mccp_version is None : self . _mccp_version = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccp_version } negotiation enabled.\" ) return True return False return bool ( super () . on_enable_remote ( option )) # pragma: no cover def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 if option in { MCCP1 , MCCP2 }: logger . debug ( f \"MCCP { self . _mccp_version if self . _mccp_version is not None else '' } negotiation disabled.\" ) self . disable_mccp () return super () . on_disable_remote ( option ) # type: ignore[safe-super] # pragma: no cover","title":"MCCPMixIn"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.__init__","text":"Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/mccp.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . subnegotiation_map [ MCCP1 ] = lambda * args : None self . subnegotiation_map [ MCCP2 ] = lambda * args : None self . _compression_enabled : bool = False self . _mccp_version : Union [ int , None ] = None self . _compressed_input_buffer : bytearray = bytearray () self . _decompressor : Any = None","title":"__init__()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.disable_mccp","text":"Disables compression. Source code in mudproto/mccp.py def disable_mccp ( self ) -> None : \"\"\"Disables compression.\"\"\" self . _mccp_version = None self . _compression_enabled = False self . _decompressor = None","title":"disable_mccp()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/mccp.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/mccp.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.get_option_state","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/mccp.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"get_option_state()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/mccp.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connection_lost()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/mccp.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connection_made()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mccp.py def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 input_buffer : bytearray = self . _compressed_input_buffer input_buffer . extend ( data ) while input_buffer : if self . _compression_enabled : # Data is compressed. super () . on_data_received ( self . _decompressor . decompress ( input_buffer )) input_buffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data. # Likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) input_buffer . extend ( self . _decompressor . unused_data ) state = self . get_option_state ( MCCP1 if self . _mccp_version == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disable_mccp () continue # Process the remaining uncompressed data. return # input_buffer is empty, no need to loop again. # Data is uncompressed. iac_index : int = input_buffer . find ( IAC ) if self . _mccp_version is not None and iac_index != - 1 : # MCCP was negotiated on, and an IAC byte was found. if iac_index > 0 : super () . on_data_received ( bytes ( input_buffer [: iac_index ])) del input_buffer [: iac_index ] if input_buffer == IAC : # Partial IAC sequence. return if input_buffer . startswith ( IAC_SB ): se_index : int = input_buffer . find ( SE ) if se_index == - 1 : # Partial subnegotiation sequence. return if input_buffer . startswith ( MCCP_ENABLED_RESPONSES ): # The server enabled compression. Subsequent data will be compressed. self . _compression_enabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_data_received ( bytes ( input_buffer [: se_index + 1 ])) del input_buffer [: se_index + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_data_received ( bytes ( input_buffer [: 2 ])) del input_buffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_data_received ( bytes ( input_buffer )) input_buffer . clear ()","title":"on_data_received()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_disable_local","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disable_local()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_disable_remote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 if option in { MCCP1 , MCCP2 }: logger . debug ( f \"MCCP { self . _mccp_version if self . _mccp_version is not None else '' } negotiation disabled.\" ) self . disable_mccp () return super () . on_disable_remote ( option ) # type: ignore[safe-super] # pragma: no cover","title":"on_disable_remote()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_enable_local","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/mccp.py @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default.","title":"on_enable_local()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_enable_remote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/mccp.py def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 if option in { MCCP1 , MCCP2 }: if self . _mccp_version is None : self . _mccp_version = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccp_version } negotiation enabled.\" ) return True return False return bool ( super () . on_enable_remote ( option )) # pragma: no cover","title":"on_enable_remote()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_option_enabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/mccp.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_option_enabled()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_unhandled_command","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandled_command()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_unhandled_subnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandled_subnegotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.request_negotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"request_negotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/mccp.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/mccp.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mccp.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/mpi/","text":"Module mudproto.mpi \u00b6 Mume Remote Editing Protocol. Class MPIProtocol( ConnectionInterface ) \u00b6 Implements support for the Mume remote editing protocol. Source code in mudproto/mpi.py class MPIProtocol ( ConnectionInterface ): \"\"\"Implements support for the Mume remote editing protocol.\"\"\" def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. Raises: ValueError: Editor or pager not found. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _mpi_buffer : bytearray = bytearray () self . _mpi_threads : list [ threading . Thread ] = [] self . command_map : MPICommandMapType = { b \"E\" : self . edit , b \"V\" : self . view , } \"\"\"A mapping of bytes to callables.\"\"\" editors : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } default_editor : str = editors . get ( sys . platform , \"nano\" ) default_pager : str = pagers . get ( sys . platform , \"less\" ) editor : Union [ str , None ] = shutil . which ( os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , default_editor ) ) pager : Union [ str , None ] = shutil . which ( os . getenv ( \"PAGER\" , default_pager )) self . _is_word_wrapping : bool = False if editor is None : # pragma: no cover raise ValueError ( \"MPI editor executable not found.\" ) if pager is None : # pragma: no cover raise ValueError ( \"MPI pager executable not found.\" ) self . editor : str = editor \"\"\"The program to use for editing received text.\"\"\" self . pager : str = pager \"\"\"The program to use for viewing received read-only text.\"\"\" @property def is_word_wrapping ( self ) -> bool : \"\"\"Specifies whether text should be word wrapped during editing or not.\"\"\" return self . _is_word_wrapping @is_word_wrapping . setter def is_word_wrapping ( self , value : bool ) -> None : self . _is_word_wrapping = value def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" # Use windows line endings when editing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. session , _ , body = str ( data , \"latin-1\" )[ 1 :] . split ( \" \\n \" , 2 ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as temp_file_obj : file_name = temp_file_obj . name temp_file_obj . write ( body ) last_modified = os . path . getmtime ( file_name ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { file_name } :MPICOMMAND\" ) input ( \"Continue:\" ) else : subprocess . run (( * self . editor . split (), file_name )) # NOQA: PLW1510, S603 response : str if os . path . getmtime ( file_name ) == last_modified : # The user closed the text editor without saving. Cancel the editing session. response = f \"C { session } \\n \" else : if self . is_word_wrapping : with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : text : str = file_obj . read () text = self . postprocess ( text ) with open ( file_name , \"w\" , encoding = \"utf-8\" , newline = newline ) as file_obj : file_obj . write ( text ) with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : response = f \"E { session } \\n { file_obj . read () . strip () } \\n \" os . remove ( file_name ) # MUME requires that output body be encoded in Latin-1 with Unix line endings. output : bytes = bytes ( response , \"latin-1\" ) . replace ( CR , b \"\" ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( output ) + LF + output ) def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" # Use windows line endings when viewing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. body : str = str ( data , \"latin-1\" ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as file_obj : file_name = file_obj . name file_obj . write ( body ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { file_name } :MPICOMMAND\" ) else : subprocess . run (( * self . pager . split (), file_name )) # NOQA: PLW1510, S603 os . remove ( file_name ) def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : app_data , separator , data = data . partition ( LF ) app_data_buffer . extend ( app_data + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _mpi_buffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () self . _mpi_buffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _mpi_buffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _mpi_buffer ) + data self . _mpi_buffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _mpi_buffer . extend ( length ) if not self . _mpi_buffer . isdigit (): logger . warning ( f \"Invalid data { self . _mpi_buffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _mpi_buffer ) + separator + data del self . _command self . _mpi_buffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _mpi_buffer ) self . _mpi_buffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _mpi_buffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _mpi_buffer )) del self . _command del self . _length self . _mpi_buffer . clear () self . state = MPIState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . command_map : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandled_command ( command , data ) elif self . command_map [ command ] is not None : thread = threading . Thread ( target = self . command_map [ command ], args = ( data ,), daemon = True ) self . _mpi_threads . append ( thread ) thread . start () def on_connection_made ( self ) -> None : # NOQA: D102 # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) def on_connection_lost ( self ) -> None : # NOQA: D102 # Clean up any active editing sessions. for thread in self . _mpi_threads : thread . join () self . _mpi_threads . clear () def on_unhandled_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_data_received ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . get_paragraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . is_comment ( paragraph ): paragraphs [ i ] = self . word_wrap ( self . capitalise ( self . collapse_spaces ( paragraph ))) return \" \\n \" . join ( paragraphs ) def get_paragraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . is_comment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] @staticmethod def is_comment ( line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) @staticmethod def collapse_spaces ( text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines return text . replace ( \" \\0 \" , \" \\n \" ) @staticmethod def capitalise ( text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) @staticmethod def word_wrap ( text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False ) Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Attribute is_word_wrapping : bool property writable \u00b6 Specifies whether text should be word wrapped during editing or not. Method __init__ ( self , * args , * , output_format , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () output_format str The output format to be used. required **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Exceptions: Type Description ValueError Editor or pager not found. Source code in mudproto/mpi.py def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. Raises: ValueError: Editor or pager not found. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _mpi_buffer : bytearray = bytearray () self . _mpi_threads : list [ threading . Thread ] = [] self . command_map : MPICommandMapType = { b \"E\" : self . edit , b \"V\" : self . view , } \"\"\"A mapping of bytes to callables.\"\"\" editors : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } default_editor : str = editors . get ( sys . platform , \"nano\" ) default_pager : str = pagers . get ( sys . platform , \"less\" ) editor : Union [ str , None ] = shutil . which ( os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , default_editor ) ) pager : Union [ str , None ] = shutil . which ( os . getenv ( \"PAGER\" , default_pager )) self . _is_word_wrapping : bool = False if editor is None : # pragma: no cover raise ValueError ( \"MPI editor executable not found.\" ) if pager is None : # pragma: no cover raise ValueError ( \"MPI pager executable not found.\" ) self . editor : str = editor \"\"\"The program to use for editing received text.\"\"\" self . pager : str = pager \"\"\"The program to use for viewing received read-only text.\"\"\" Method capitalise ( text ) staticmethod \u00b6 Capitalizes each sentence in a string. Parameters: Name Type Description Default text str The text to perform sentence capitalization on. required Returns: Type Description str The text after each sentence has been capitalized. Source code in mudproto/mpi.py @staticmethod def capitalise ( text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) Method collapse_spaces ( text ) staticmethod \u00b6 Collapses all consecutive space and tab characters of a string to a single space character. Parameters: Name Type Description Default text str The text to perform the operation on. required Returns: Type Description str The text with consecutive space and tab characters collapsed. Source code in mudproto/mpi.py @staticmethod def collapse_spaces ( text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines return text . replace ( \" \\0 \" , \" \\n \" ) Method edit ( self , data ) \u00b6 Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mudproto/mpi.py def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" # Use windows line endings when editing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. session , _ , body = str ( data , \"latin-1\" )[ 1 :] . split ( \" \\n \" , 2 ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as temp_file_obj : file_name = temp_file_obj . name temp_file_obj . write ( body ) last_modified = os . path . getmtime ( file_name ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { file_name } :MPICOMMAND\" ) input ( \"Continue:\" ) else : subprocess . run (( * self . editor . split (), file_name )) # NOQA: PLW1510, S603 response : str if os . path . getmtime ( file_name ) == last_modified : # The user closed the text editor without saving. Cancel the editing session. response = f \"C { session } \\n \" else : if self . is_word_wrapping : with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : text : str = file_obj . read () text = self . postprocess ( text ) with open ( file_name , \"w\" , encoding = \"utf-8\" , newline = newline ) as file_obj : file_obj . write ( text ) with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : response = f \"E { session } \\n { file_obj . read () . strip () } \\n \" os . remove ( file_name ) # MUME requires that output body be encoded in Latin-1 with Unix line endings. output : bytes = bytes ( response , \"latin-1\" ) . replace ( CR , b \"\" ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( output ) + LF + output ) Method get_paragraphs ( self , text ) \u00b6 Extracts paragraphs from a string. Parameters: Name Type Description Default text str The text to analyze. required Returns: Type Description list[str] The extracted paragraphs. Source code in mudproto/mpi.py def get_paragraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . is_comment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] Method is_comment ( line ) staticmethod \u00b6 Determines whether a line is a comment. Parameters: Name Type Description Default line str The line to analyze. required Returns: Type Description bool True if the line is a comment, False otherwise. Source code in mudproto/mpi.py @staticmethod def is_comment ( line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) Method on_command ( self , command , data ) \u00b6 Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . command_map : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandled_command ( command , data ) elif self . command_map [ command ] is not None : thread = threading . Thread ( target = self . command_map [ command ], args = ( data ,), daemon = True ) self . _mpi_threads . append ( thread ) thread . start () Method on_connection_lost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/mpi.py def on_connection_lost ( self ) -> None : # NOQA: D102 # Clean up any active editing sessions. for thread in self . _mpi_threads : thread . join () self . _mpi_threads . clear () Method on_connection_made ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/mpi.py def on_connection_made ( self ) -> None : # NOQA: D102 # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) Method on_data_received ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mpi.py def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : app_data , separator , data = data . partition ( LF ) app_data_buffer . extend ( app_data + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _mpi_buffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () self . _mpi_buffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _mpi_buffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _mpi_buffer ) + data self . _mpi_buffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _mpi_buffer . extend ( length ) if not self . _mpi_buffer . isdigit (): logger . warning ( f \"Invalid data { self . _mpi_buffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _mpi_buffer ) + separator + data del self . _command self . _mpi_buffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _mpi_buffer ) self . _mpi_buffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _mpi_buffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _mpi_buffer )) del self . _command del self . _length self . _mpi_buffer . clear () self . state = MPIState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) Method on_unhandled_command ( self , command , data ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_unhandled_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_data_received ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) Method postprocess ( self , text ) \u00b6 Reformats text before it is sent to the game when wordwrapping is enabled. Parameters: Name Type Description Default text str The text to be processed. required Returns: Type Description str The text with formatting applied. Source code in mudproto/mpi.py def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . get_paragraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . is_comment ( paragraph ): paragraphs [ i ] = self . word_wrap ( self . capitalise ( self . collapse_spaces ( paragraph ))) return \" \\n \" . join ( paragraphs ) Method view ( self , data ) \u00b6 Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mudproto/mpi.py def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" # Use windows line endings when viewing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. body : str = str ( data , \"latin-1\" ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as file_obj : file_name = file_obj . name file_obj . write ( body ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { file_name } :MPICOMMAND\" ) else : subprocess . run (( * self . pager . split (), file_name )) # NOQA: PLW1510, S603 os . remove ( file_name ) Method word_wrap ( text ) staticmethod \u00b6 Wordwraps text using module-specific settings. Parameters: Name Type Description Default text str The text to be wordwrapped. required Returns: Type Description str The text with wordwrapping applied. Source code in mudproto/mpi.py @staticmethod def word_wrap ( text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mpi.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) Class MPIState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/mpi.py class MPIState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () NEWLINE = auto () INIT = auto () COMMAND = auto () LENGTH = auto () BODY = auto ()","title":"mpi.py"},{"location":"api/mpi/#mudproto.mpi","text":"Mume Remote Editing Protocol.","title":"mpi"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol","text":"Implements support for the Mume remote editing protocol. Source code in mudproto/mpi.py class MPIProtocol ( ConnectionInterface ): \"\"\"Implements support for the Mume remote editing protocol.\"\"\" def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. Raises: ValueError: Editor or pager not found. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _mpi_buffer : bytearray = bytearray () self . _mpi_threads : list [ threading . Thread ] = [] self . command_map : MPICommandMapType = { b \"E\" : self . edit , b \"V\" : self . view , } \"\"\"A mapping of bytes to callables.\"\"\" editors : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } default_editor : str = editors . get ( sys . platform , \"nano\" ) default_pager : str = pagers . get ( sys . platform , \"less\" ) editor : Union [ str , None ] = shutil . which ( os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , default_editor ) ) pager : Union [ str , None ] = shutil . which ( os . getenv ( \"PAGER\" , default_pager )) self . _is_word_wrapping : bool = False if editor is None : # pragma: no cover raise ValueError ( \"MPI editor executable not found.\" ) if pager is None : # pragma: no cover raise ValueError ( \"MPI pager executable not found.\" ) self . editor : str = editor \"\"\"The program to use for editing received text.\"\"\" self . pager : str = pager \"\"\"The program to use for viewing received read-only text.\"\"\" @property def is_word_wrapping ( self ) -> bool : \"\"\"Specifies whether text should be word wrapped during editing or not.\"\"\" return self . _is_word_wrapping @is_word_wrapping . setter def is_word_wrapping ( self , value : bool ) -> None : self . _is_word_wrapping = value def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" # Use windows line endings when editing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. session , _ , body = str ( data , \"latin-1\" )[ 1 :] . split ( \" \\n \" , 2 ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as temp_file_obj : file_name = temp_file_obj . name temp_file_obj . write ( body ) last_modified = os . path . getmtime ( file_name ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { file_name } :MPICOMMAND\" ) input ( \"Continue:\" ) else : subprocess . run (( * self . editor . split (), file_name )) # NOQA: PLW1510, S603 response : str if os . path . getmtime ( file_name ) == last_modified : # The user closed the text editor without saving. Cancel the editing session. response = f \"C { session } \\n \" else : if self . is_word_wrapping : with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : text : str = file_obj . read () text = self . postprocess ( text ) with open ( file_name , \"w\" , encoding = \"utf-8\" , newline = newline ) as file_obj : file_obj . write ( text ) with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : response = f \"E { session } \\n { file_obj . read () . strip () } \\n \" os . remove ( file_name ) # MUME requires that output body be encoded in Latin-1 with Unix line endings. output : bytes = bytes ( response , \"latin-1\" ) . replace ( CR , b \"\" ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( output ) + LF + output ) def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" # Use windows line endings when viewing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. body : str = str ( data , \"latin-1\" ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as file_obj : file_name = file_obj . name file_obj . write ( body ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { file_name } :MPICOMMAND\" ) else : subprocess . run (( * self . pager . split (), file_name )) # NOQA: PLW1510, S603 os . remove ( file_name ) def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : app_data , separator , data = data . partition ( LF ) app_data_buffer . extend ( app_data + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _mpi_buffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () self . _mpi_buffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _mpi_buffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _mpi_buffer ) + data self . _mpi_buffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _mpi_buffer . extend ( length ) if not self . _mpi_buffer . isdigit (): logger . warning ( f \"Invalid data { self . _mpi_buffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _mpi_buffer ) + separator + data del self . _command self . _mpi_buffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _mpi_buffer ) self . _mpi_buffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _mpi_buffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _mpi_buffer )) del self . _command del self . _length self . _mpi_buffer . clear () self . state = MPIState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . command_map : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandled_command ( command , data ) elif self . command_map [ command ] is not None : thread = threading . Thread ( target = self . command_map [ command ], args = ( data ,), daemon = True ) self . _mpi_threads . append ( thread ) thread . start () def on_connection_made ( self ) -> None : # NOQA: D102 # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) def on_connection_lost ( self ) -> None : # NOQA: D102 # Clean up any active editing sessions. for thread in self . _mpi_threads : thread . join () self . _mpi_threads . clear () def on_unhandled_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_data_received ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . get_paragraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . is_comment ( paragraph ): paragraphs [ i ] = self . word_wrap ( self . capitalise ( self . collapse_spaces ( paragraph ))) return \" \\n \" . join ( paragraphs ) def get_paragraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . is_comment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] @staticmethod def is_comment ( line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) @staticmethod def collapse_spaces ( text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines return text . replace ( \" \\0 \" , \" \\n \" ) @staticmethod def capitalise ( text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) @staticmethod def word_wrap ( text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False )","title":"MPIProtocol"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.is_word_wrapping","text":"Specifies whether text should be word wrapped during editing or not.","title":"is_word_wrapping"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.__init__","text":"Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () output_format str The output format to be used. required **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Exceptions: Type Description ValueError Editor or pager not found. Source code in mudproto/mpi.py def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. Raises: ValueError: Editor or pager not found. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _mpi_buffer : bytearray = bytearray () self . _mpi_threads : list [ threading . Thread ] = [] self . command_map : MPICommandMapType = { b \"E\" : self . edit , b \"V\" : self . view , } \"\"\"A mapping of bytes to callables.\"\"\" editors : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad.exe\" , } default_editor : str = editors . get ( sys . platform , \"nano\" ) default_pager : str = pagers . get ( sys . platform , \"less\" ) editor : Union [ str , None ] = shutil . which ( os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , default_editor ) ) pager : Union [ str , None ] = shutil . which ( os . getenv ( \"PAGER\" , default_pager )) self . _is_word_wrapping : bool = False if editor is None : # pragma: no cover raise ValueError ( \"MPI editor executable not found.\" ) if pager is None : # pragma: no cover raise ValueError ( \"MPI pager executable not found.\" ) self . editor : str = editor \"\"\"The program to use for editing received text.\"\"\" self . pager : str = pager \"\"\"The program to use for viewing received read-only text.\"\"\"","title":"__init__()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.capitalise","text":"Capitalizes each sentence in a string. Parameters: Name Type Description Default text str The text to perform sentence capitalization on. required Returns: Type Description str The text after each sentence has been capitalized. Source code in mudproto/mpi.py @staticmethod def capitalise ( text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" ))","title":"capitalise()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.collapse_spaces","text":"Collapses all consecutive space and tab characters of a string to a single space character. Parameters: Name Type Description Default text str The text to perform the operation on. required Returns: Type Description str The text with consecutive space and tab characters collapsed. Source code in mudproto/mpi.py @staticmethod def collapse_spaces ( text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines return text . replace ( \" \\0 \" , \" \\n \" )","title":"collapse_spaces()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.edit","text":"Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mudproto/mpi.py def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" # Use windows line endings when editing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. session , _ , body = str ( data , \"latin-1\" )[ 1 :] . split ( \" \\n \" , 2 ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as temp_file_obj : file_name = temp_file_obj . name temp_file_obj . write ( body ) last_modified = os . path . getmtime ( file_name ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { file_name } :MPICOMMAND\" ) input ( \"Continue:\" ) else : subprocess . run (( * self . editor . split (), file_name )) # NOQA: PLW1510, S603 response : str if os . path . getmtime ( file_name ) == last_modified : # The user closed the text editor without saving. Cancel the editing session. response = f \"C { session } \\n \" else : if self . is_word_wrapping : with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : text : str = file_obj . read () text = self . postprocess ( text ) with open ( file_name , \"w\" , encoding = \"utf-8\" , newline = newline ) as file_obj : file_obj . write ( text ) with open ( file_name , encoding = \"utf-8\" , newline = newline ) as file_obj : response = f \"E { session } \\n { file_obj . read () . strip () } \\n \" os . remove ( file_name ) # MUME requires that output body be encoded in Latin-1 with Unix line endings. output : bytes = bytes ( response , \"latin-1\" ) . replace ( CR , b \"\" ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( output ) + LF + output )","title":"edit()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.get_paragraphs","text":"Extracts paragraphs from a string. Parameters: Name Type Description Default text str The text to analyze. required Returns: Type Description list[str] The extracted paragraphs. Source code in mudproto/mpi.py def get_paragraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . is_comment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ]","title":"get_paragraphs()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.is_comment","text":"Determines whether a line is a comment. Parameters: Name Type Description Default line str The line to analyze. required Returns: Type Description bool True if the line is a comment, False otherwise. Source code in mudproto/mpi.py @staticmethod def is_comment ( line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" )","title":"is_comment()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_command","text":"Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . command_map : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandled_command ( command , data ) elif self . command_map [ command ] is not None : thread = threading . Thread ( target = self . command_map [ command ], args = ( data ,), daemon = True ) self . _mpi_threads . append ( thread ) thread . start ()","title":"on_command()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/mpi.py def on_connection_lost ( self ) -> None : # NOQA: D102 # Clean up any active editing sessions. for thread in self . _mpi_threads : thread . join () self . _mpi_threads . clear ()","title":"on_connection_lost()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/mpi.py def on_connection_made ( self ) -> None : # NOQA: D102 # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF )","title":"on_connection_made()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mpi.py def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : app_data , separator , data = data . partition ( LF ) app_data_buffer . extend ( app_data + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _mpi_buffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () self . _mpi_buffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _mpi_buffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _mpi_buffer ) + data self . _mpi_buffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _mpi_buffer . extend ( length ) if not self . _mpi_buffer . isdigit (): logger . warning ( f \"Invalid data { self . _mpi_buffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _mpi_buffer ) + separator + data del self . _command self . _mpi_buffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _mpi_buffer ) self . _mpi_buffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _mpi_buffer ) self . _mpi_buffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _mpi_buffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _mpi_buffer )) del self . _command del self . _length self . _mpi_buffer . clear () self . state = MPIState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer ))","title":"on_data_received()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_unhandled_command","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_unhandled_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_data_received ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data )","title":"on_unhandled_command()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.postprocess","text":"Reformats text before it is sent to the game when wordwrapping is enabled. Parameters: Name Type Description Default text str The text to be processed. required Returns: Type Description str The text with formatting applied. Source code in mudproto/mpi.py def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . get_paragraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . is_comment ( paragraph ): paragraphs [ i ] = self . word_wrap ( self . capitalise ( self . collapse_spaces ( paragraph ))) return \" \\n \" . join ( paragraphs )","title":"postprocess()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.view","text":"Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mudproto/mpi.py def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" # Use windows line endings when viewing the file. newline : str = \" \\r\\n \" # The MUME server sends the MPI data encoded in Latin-1. body : str = str ( data , \"latin-1\" ) with tempfile . NamedTemporaryFile ( \"w\" , encoding = \"utf-8\" , newline = newline , prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as file_obj : file_name = file_obj . name file_obj . write ( body ) if self . output_format == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { file_name } :MPICOMMAND\" ) else : subprocess . run (( * self . pager . split (), file_name )) # NOQA: PLW1510, S603 os . remove ( file_name )","title":"view()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.word_wrap","text":"Wordwraps text using module-specific settings. Parameters: Name Type Description Default text str The text to be wordwrapped. required Returns: Type Description str The text with wordwrapping applied. Source code in mudproto/mpi.py @staticmethod def word_wrap ( text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False )","title":"word_wrap()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mpi.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/mpi/#mudproto.mpi.MPIState","text":"Valid states for the state machine. Source code in mudproto/mpi.py class MPIState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () NEWLINE = auto () INIT = auto () COMMAND = auto () LENGTH = auto () BODY = auto ()","title":"MPIState"},{"location":"api/telnet/","text":"Module mudproto.telnet \u00b6 Telnet protocol. Class TelnetError( Exception ) \u00b6 Implements the base class for Telnet exceptions. Source code in mudproto/telnet.py class TelnetError ( Exception ): \"\"\"Implements the base class for Telnet exceptions.\"\"\" Class TelnetInterface( ConnectionInterface ) \u00b6 Defines the interface for the Telnet protocol. Source code in mudproto/telnet.py class TelnetInterface ( ConnectionInterface ): \"\"\"Defines the interface for the Telnet protocol.\"\"\" command_map : TelnetCommandMapType \"\"\"A mapping of bytes to callables.\"\"\" subnegotiation_map : TelnetSubnegotiationMapType \"\"\"A mapping of bytes to callables.\"\"\" @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default. @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default. @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method do ( self , option ) \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method get_option_state ( self , option ) \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connection_lost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connection_made ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_data_received ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data ) Method on_disable_local ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disable_remote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) Method on_enable_local ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default. Method on_enable_remote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default. Method on_option_enabled ( self , option ) \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandled_command ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandled_subnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method request_negotiation ( self , option , data ) \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) Class TelnetProtocol( TelnetInterface ) \u00b6 Implements the Telnet protocol. Source code in mudproto/telnet.py class TelnetProtocol ( TelnetInterface ): # NOQA: PLR0904 \"\"\"Implements the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte, # the first byte after IAC, is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . command_map : TelnetCommandMapType = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte, the # first byte after SB, is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiation_map : TelnetSubnegotiationMapType = {} def _do ( self , option : bytes ) -> None : \"\"\" Sends IAC DO option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DO { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DO + option ) def _dont ( self , option : bytes ) -> None : \"\"\" Sends IAC DONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DONT + option ) def _will ( self , option : bytes ) -> None : \"\"\" Sends IAC WILL option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WILL { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WILL + option ) def _wont ( self , option : bytes ) -> None : \"\"\" Sends IAC WONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WONT + option ) def will ( self , option : bytes ) -> None : \"\"\" Tells peer we would like to enable a Telnet option. Args: option: The option we wish to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) def wont ( self , option : bytes ) -> None : \"\"\" Tells peer we no longer wish to enable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) def do ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to enable a Telnet option. Args: option: The option we wish peer to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) def dont ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to disable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Retrieves the state of an option. Args: option: The option we wish to get the state of. Returns: The option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Performs a Telnet sub-negotiation for the given option. Args: option: The option we are negotiating. data: The data we are sending in the body of the negotiation. \"\"\" self . write ( IAC + SB + option + escape_iac ( data ) + IAC + SE ) def on_connection_made ( self ) -> None : # NOQA: D102 return super () . on_connection_made () # type: ignore[safe-super] def on_connection_lost ( self ) -> None : # NOQA: D102 return super () . on_connection_lost () # type: ignore[safe-super] def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : app_data , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif app_data . endswith ( CR ): self . state = TelnetState . NEWLINE app_data = app_data [: - 1 ] app_data_buffer . extend ( app_data . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. app_data_buffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : app_data_buffer . extend ( byte ) elif byte == NULL : app_data_buffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing, cursor to next line, first column, # CR + NUL another, cursor to first column. Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. app_data_buffer . extend ( CR ) self . state = TelnetState . COMMAND else : app_data_buffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } \" + f \" { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 if command in self . command_map : self . command_map [ command ]( option ) else : self . on_unhandled_command ( command , option ) def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 if option in self . subnegotiation_map : self . subnegotiation_map [ option ]( data ) else : self . on_unhandled_subnegotiation ( option , data ) def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enable_remote ( option ): state . him . enabled = True self . _do ( option ) self . on_option_enabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enable_remote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_option_enabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( \"him.enabled and him.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this, although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't. pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } \" + \"in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disable_remote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disable_remote ( option ) def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enable_local ( option ): state . us . enabled = True self . _will ( option ) self . on_option_enabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enable_local ( option ) self . on_option_enabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( \"us.enabled and us.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disable_local ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disable_local ( option ) def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 return super () . on_unhandled_command ( command , option ) # type: ignore[safe-super] def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 return super () . on_unhandled_subnegotiation ( option , data ) # type: ignore[safe-super] def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_local ( option ) def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_local ( option ) # type: ignore[safe-super] def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_remote ( option ) def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_remote ( option ) # type: ignore[safe-super] def on_option_enabled ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_option_enabled ( option ) # type: ignore[safe-super] Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , * args , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/telnet.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte, # the first byte after IAC, is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . command_map : TelnetCommandMapType = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte, the # first byte after SB, is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiation_map : TelnetSubnegotiationMapType = {} Method do ( self , option ) \u00b6 Tells peer we would like him to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish peer to enable. required Source code in mudproto/telnet.py def do ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to enable a Telnet option. Args: option: The option we wish peer to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) \u00b6 Tells peer we would like him to disable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to disable. required Source code in mudproto/telnet.py def dont ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to disable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method get_option_state ( self , option ) \u00b6 Retrieves the state of an option. Parameters: Name Type Description Default option bytes The option we wish to get the state of. required Returns: Type Description _OptionState The option state. Source code in mudproto/telnet.py def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Retrieves the state of an option. Args: option: The option we wish to get the state of. Returns: The option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 if command in self . command_map : self . command_map [ command ]( option ) else : self . on_unhandled_command ( command , option ) Method on_connection_lost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py def on_connection_lost ( self ) -> None : # NOQA: D102 return super () . on_connection_lost () # type: ignore[safe-super] Method on_connection_made ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py def on_connection_made ( self ) -> None : # NOQA: D102 return super () . on_connection_made () # type: ignore[safe-super] Method on_data_received ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : app_data , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif app_data . endswith ( CR ): self . state = TelnetState . NEWLINE app_data = app_data [: - 1 ] app_data_buffer . extend ( app_data . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. app_data_buffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : app_data_buffer . extend ( byte ) elif byte == NULL : app_data_buffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing, cursor to next line, first column, # CR + NUL another, cursor to first column. Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. app_data_buffer . extend ( CR ) self . state = TelnetState . COMMAND else : app_data_buffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } \" + f \" { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) Method on_disable_local ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_local ( option ) # type: ignore[safe-super] Method on_disable_remote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_remote ( option ) # type: ignore[safe-super] Method on_do ( self , option ) \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enable_local ( option ): state . us . enabled = True self . _will ( option ) self . on_option_enabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enable_local ( option ) self . on_option_enabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( \"us.enabled and us.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disable_local ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disable_local ( option ) Method on_enable_local ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_local ( option ) Method on_enable_remote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_remote ( option ) Method on_option_enabled ( self , option ) \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py def on_option_enabled ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_option_enabled ( option ) # type: ignore[safe-super] Method on_subnegotiation ( self , option , data ) \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 if option in self . subnegotiation_map : self . subnegotiation_map [ option ]( data ) else : self . on_unhandled_subnegotiation ( option , data ) Method on_unhandled_command ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 return super () . on_unhandled_command ( command , option ) # type: ignore[safe-super] Method on_unhandled_subnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 return super () . on_unhandled_subnegotiation ( option , data ) # type: ignore[safe-super] Method on_will ( self , option ) \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enable_remote ( option ): state . him . enabled = True self . _do ( option ) self . on_option_enabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enable_remote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_option_enabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( \"him.enabled and him.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this, although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't. pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } \" + \"in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disable_remote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disable_remote ( option ) Method request_negotiation ( self , option , data ) \u00b6 Performs a Telnet sub-negotiation for the given option. Parameters: Name Type Description Default option bytes The option we are negotiating. required data bytes The data we are sending in the body of the negotiation. required Source code in mudproto/telnet.py def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Performs a Telnet sub-negotiation for the given option. Args: option: The option we are negotiating. data: The data we are sending in the body of the negotiation. \"\"\" self . write ( IAC + SB + option + escape_iac ( data ) + IAC + SE ) Method will ( self , option ) \u00b6 Tells peer we would like to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to enable. required Source code in mudproto/telnet.py def will ( self , option : bytes ) -> None : \"\"\" Tells peer we would like to enable a Telnet option. Args: option: The option we wish to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) \u00b6 Tells peer we no longer wish to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to disable. required Source code in mudproto/telnet.py def wont ( self , option : bytes ) -> None : \"\"\" Tells peer we no longer wish to enable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) Class TelnetState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/telnet.py class TelnetState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () COMMAND = auto () NEWLINE = auto () NEGOTIATION = auto () SUBNEGOTIATION = auto () SUBNEGOTIATION_ESCAPED = auto () Function escape_iac ( data ) \u00b6 Escapes IAC bytes of a bytes-like object. Parameters: Name Type Description Default data bytes The data to be escaped. required Returns: Type Description bytes The data with IAC bytes escaped. Source code in mudproto/telnet.py def escape_iac ( data : bytes ) -> bytes : \"\"\" Escapes IAC bytes of a bytes-like object. Args: data: The data to be escaped. Returns: The data with IAC bytes escaped. \"\"\" return data . replace ( IAC , IAC_IAC )","title":"telnet.py"},{"location":"api/telnet/#mudproto.telnet","text":"Telnet protocol.","title":"telnet"},{"location":"api/telnet/#mudproto.telnet.TelnetError","text":"Implements the base class for Telnet exceptions. Source code in mudproto/telnet.py class TelnetError ( Exception ): \"\"\"Implements the base class for Telnet exceptions.\"\"\"","title":"TelnetError"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface","text":"Defines the interface for the Telnet protocol. Source code in mudproto/telnet.py class TelnetInterface ( ConnectionInterface ): \"\"\"Defines the interface for the Telnet protocol.\"\"\" command_map : TelnetCommandMapType \"\"\"A mapping of bytes to callables.\"\"\" subnegotiation_map : TelnetSubnegotiationMapType \"\"\"A mapping of bytes to callables.\"\"\" @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default. @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default. @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"TelnetInterface"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.get_option_state","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py @abstractmethod def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"get_option_state()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py @abstractmethod def on_connection_lost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connection_lost()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py @abstractmethod def on_connection_made ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connection_made()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py @abstractmethod def on_data_received ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" self . _receiver ( data )","title":"on_data_received()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_disable_local","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disable_local ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enable_local is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disable_local()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_disable_remote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disable_remote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enable_remote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" )","title":"on_disable_remote()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_enable_local","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enable_local ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" return False # Reject all options by default.","title":"on_enable_local()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_enable_remote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enable_remote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" return False # Reject all options by default.","title":"on_enable_remote()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_option_enabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py @abstractmethod def on_option_enabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_option_enabled()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_unhandled_command","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandled_command()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.on_unhandled_subnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandled_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.request_negotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"request_negotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/telnet/#mudproto.telnet.TelnetInterface.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol","text":"Implements the Telnet protocol. Source code in mudproto/telnet.py class TelnetProtocol ( TelnetInterface ): # NOQA: PLR0904 \"\"\"Implements the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte, # the first byte after IAC, is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . command_map : TelnetCommandMapType = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte, the # first byte after SB, is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiation_map : TelnetSubnegotiationMapType = {} def _do ( self , option : bytes ) -> None : \"\"\" Sends IAC DO option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DO { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DO + option ) def _dont ( self , option : bytes ) -> None : \"\"\" Sends IAC DONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DONT + option ) def _will ( self , option : bytes ) -> None : \"\"\" Sends IAC WILL option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WILL { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WILL + option ) def _wont ( self , option : bytes ) -> None : \"\"\" Sends IAC WONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WONT + option ) def will ( self , option : bytes ) -> None : \"\"\" Tells peer we would like to enable a Telnet option. Args: option: The option we wish to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) def wont ( self , option : bytes ) -> None : \"\"\" Tells peer we no longer wish to enable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) def do ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to enable a Telnet option. Args: option: The option we wish peer to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) def dont ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to disable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Retrieves the state of an option. Args: option: The option we wish to get the state of. Returns: The option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Performs a Telnet sub-negotiation for the given option. Args: option: The option we are negotiating. data: The data we are sending in the body of the negotiation. \"\"\" self . write ( IAC + SB + option + escape_iac ( data ) + IAC + SE ) def on_connection_made ( self ) -> None : # NOQA: D102 return super () . on_connection_made () # type: ignore[safe-super] def on_connection_lost ( self ) -> None : # NOQA: D102 return super () . on_connection_lost () # type: ignore[safe-super] def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : app_data , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif app_data . endswith ( CR ): self . state = TelnetState . NEWLINE app_data = app_data [: - 1 ] app_data_buffer . extend ( app_data . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. app_data_buffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : app_data_buffer . extend ( byte ) elif byte == NULL : app_data_buffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing, cursor to next line, first column, # CR + NUL another, cursor to first column. Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. app_data_buffer . extend ( CR ) self . state = TelnetState . COMMAND else : app_data_buffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } \" + f \" { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 if command in self . command_map : self . command_map [ command ]( option ) else : self . on_unhandled_command ( command , option ) def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 if option in self . subnegotiation_map : self . subnegotiation_map [ option ]( data ) else : self . on_unhandled_subnegotiation ( option , data ) def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enable_remote ( option ): state . him . enabled = True self . _do ( option ) self . on_option_enabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enable_remote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_option_enabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( \"him.enabled and him.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this, although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't. pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } \" + \"in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disable_remote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disable_remote ( option ) def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enable_local ( option ): state . us . enabled = True self . _will ( option ) self . on_option_enabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enable_local ( option ) self . on_option_enabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( \"us.enabled and us.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" ) def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disable_local ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disable_local ( option ) def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 return super () . on_unhandled_command ( command , option ) # type: ignore[safe-super] def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 return super () . on_unhandled_subnegotiation ( option , data ) # type: ignore[safe-super] def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_local ( option ) def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_local ( option ) # type: ignore[safe-super] def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_remote ( option ) def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_remote ( option ) # type: ignore[safe-super] def on_option_enabled ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_option_enabled ( option ) # type: ignore[safe-super]","title":"TelnetProtocol"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.__init__","text":"Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/telnet.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte, # the first byte after IAC, is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . command_map : TelnetCommandMapType = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte, the # first byte after SB, is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiation_map : TelnetSubnegotiationMapType = {}","title":"__init__()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.do","text":"Tells peer we would like him to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish peer to enable. required Source code in mudproto/telnet.py def do ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to enable a Telnet option. Args: option: The option we wish peer to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.dont","text":"Tells peer we would like him to disable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to disable. required Source code in mudproto/telnet.py def dont ( self , option : bytes ) -> None : \"\"\" Tells peer we would like him to disable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.get_option_state","text":"Retrieves the state of an option. Parameters: Name Type Description Default option bytes The option we wish to get the state of. required Returns: Type Description _OptionState The option state. Source code in mudproto/telnet.py def get_option_state ( self , option : bytes ) -> _OptionState : \"\"\" Retrieves the state of an option. Args: option: The option we wish to get the state of. Returns: The option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"get_option_state()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 if command in self . command_map : self . command_map [ command ]( option ) else : self . on_unhandled_command ( command , option )","title":"on_command()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py def on_connection_lost ( self ) -> None : # NOQA: D102 return super () . on_connection_lost () # type: ignore[safe-super]","title":"on_connection_lost()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py def on_connection_made ( self ) -> None : # NOQA: D102 return super () . on_connection_made () # type: ignore[safe-super]","title":"on_connection_made()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py def on_data_received ( self , data : bytes ) -> None : # NOQA: C901, D102, PLR0912, PLR0915 app_data_buffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : app_data , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif app_data . endswith ( CR ): self . state = TelnetState . NEWLINE app_data = app_data [: - 1 ] app_data_buffer . extend ( app_data . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. app_data_buffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : app_data_buffer . extend ( byte ) elif byte == NULL : app_data_buffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing, cursor to next line, first column, # CR + NUL another, cursor to first column. Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. app_data_buffer . extend ( CR ) self . state = TelnetState . COMMAND else : app_data_buffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer )) app_data_buffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } \" + f \" { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if app_data_buffer : super () . on_data_received ( bytes ( app_data_buffer ))","title":"on_data_received()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_disable_local","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enable_local is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disable_local ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_local ( option ) # type: ignore[safe-super]","title":"on_disable_local()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_disable_remote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enable_remote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disable_remote ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_disable_remote ( option ) # type: ignore[safe-super]","title":"on_disable_remote()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enable_local ( option ): state . us . enabled = True self . _will ( option ) self . on_option_enabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enable_local ( option ) self . on_option_enabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( \"us.enabled and us.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disable_local ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disable_local ( option )","title":"on_dont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_enable_local","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py def on_enable_local ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_local ( option )","title":"on_enable_local()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_enable_remote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py def on_enable_remote ( self , option : bytes ) -> bool : # NOQA: D102 return super () . on_enable_remote ( option )","title":"on_enable_remote()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_option_enabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py def on_option_enabled ( self , option : bytes ) -> None : # NOQA: D102 return super () . on_option_enabled ( option ) # type: ignore[safe-super]","title":"on_option_enabled()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 if option in self . subnegotiation_map : self . subnegotiation_map [ option ]( data ) else : self . on_unhandled_subnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_unhandled_command","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_unhandled_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : # NOQA: D102 return super () . on_unhandled_command ( command , option ) # type: ignore[safe-super]","title":"on_unhandled_command()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_unhandled_subnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_unhandled_subnegotiation ( self , option : bytes , data : bytes ) -> None : # NOQA: D102 return super () . on_unhandled_subnegotiation ( option , data ) # type: ignore[safe-super]","title":"on_unhandled_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enable_remote ( option ): state . him . enabled = True self . _do ( option ) self . on_option_enabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enable_remote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_option_enabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( \"him.enabled and him.negotiating cannot be True at the same time. \" + f \"state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" # NOQA: DOC501 if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . get_option_state ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this, although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't. pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } \" + \"in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disable_remote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disable_remote ( option )","title":"on_wont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.request_negotiation","text":"Performs a Telnet sub-negotiation for the given option. Parameters: Name Type Description Default option bytes The option we are negotiating. required data bytes The data we are sending in the body of the negotiation. required Source code in mudproto/telnet.py def request_negotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Performs a Telnet sub-negotiation for the given option. Args: option: The option we are negotiating. data: The data we are sending in the body of the negotiation. \"\"\" self . write ( IAC + SB + option + escape_iac ( data ) + IAC + SE )","title":"request_negotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.will","text":"Tells peer we would like to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to enable. required Source code in mudproto/telnet.py def will ( self , option : bytes ) -> None : \"\"\" Tells peer we would like to enable a Telnet option. Args: option: The option we wish to enable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.wont","text":"Tells peer we no longer wish to enable a Telnet option. Parameters: Name Type Description Default option bytes The option we wish to disable. required Source code in mudproto/telnet.py def wont ( self , option : bytes ) -> None : \"\"\" Tells peer we no longer wish to enable a Telnet option. Args: option: The option we wish to disable. \"\"\" state = self . get_option_state ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/telnet/#mudproto.telnet.TelnetState","text":"Valid states for the state machine. Source code in mudproto/telnet.py class TelnetState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () COMMAND = auto () NEWLINE = auto () NEGOTIATION = auto () SUBNEGOTIATION = auto () SUBNEGOTIATION_ESCAPED = auto ()","title":"TelnetState"},{"location":"api/telnet/#mudproto.telnet.escape_iac","text":"Escapes IAC bytes of a bytes-like object. Parameters: Name Type Description Default data bytes The data to be escaped. required Returns: Type Description bytes The data with IAC bytes escaped. Source code in mudproto/telnet.py def escape_iac ( data : bytes ) -> bytes : \"\"\" Escapes IAC bytes of a bytes-like object. Args: data: The data to be escaped. Returns: The data with IAC bytes escaped. \"\"\" return data . replace ( IAC , IAC_IAC )","title":"escape_iac()"},{"location":"api/xml/","text":"Module mudproto.xml \u00b6 Mume XML Protocol. Class XMLMode( Enum ) \u00b6 Valid modes corresponding to supported XML tags. Source code in mudproto/xml.py class XMLMode ( Enum ): \"\"\"Valid modes corresponding to supported XML tags.\"\"\" NONE = auto () DESCRIPTION = auto () EXITS = auto () MAGIC = auto () NAME = auto () PROMPT = auto () ROOM = auto () TERRAIN = auto () Class XMLProtocol( ConnectionInterface ) \u00b6 Implements the Mume XML protocol. Source code in mudproto/xml.py class XMLProtocol ( ConnectionInterface ): \"\"\"Implements the Mume XML protocol.\"\"\" tintin_replacements : ClassVar [ set [ bytes ]] = { b \"prompt\" , b \"name\" , b \"tell\" , b \"narrate\" , b \"pray\" , b \"say\" , b \"emote\" , } \"\"\"Tag to replacement values for Tintin.\"\"\" def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tag_buffer : bytearray = bytearray () # Used for start and end tag names. self . _text_buffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamic_buffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _line_buffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _mode : XMLMode = XMLMode . NONE self . _parent_modes : list [ XMLMode ] = [] def _handle_xml_text ( self , data : bytes , app_data_buffer : bytearray ) -> bytes : \"\"\" Handles XML data that is not part of a tag. Args: data: The received data. app_data_buffer: The application level data buffer. Returns: The remaining data. \"\"\" app_data , separator , data = data . partition ( LT ) if self . output_format == \"raw\" or not self . _gratuitous : # Gratuitous text should be omitted unless format is 'raw'. app_data_buffer . extend ( app_data ) if self . _mode is XMLMode . NONE : self . _line_buffer . extend ( app_data ) lines = self . _line_buffer . splitlines ( keepends = True ) self . _line_buffer . clear () if lines and not lines [ - 1 ] . endswith (( CR , LF )): # Final line is incomplete. self . _line_buffer . extend ( lines . pop ()) for line in lines : if line . strip (): self . on_xml_event ( \"line\" , unescape_xml_bytes ( line . rstrip ( CR_LF ))) elif self . _mode is XMLMode . ROOM : self . _dynamic_buffer . extend ( app_data ) else : self . _text_buffer . extend ( app_data ) if separator : self . state = XMLState . TAG return data def _handle_xml_tag ( self , data : bytes , app_data_buffer : bytearray ) -> bytes : # NOQA: C901, PLR0912 \"\"\" Handles XML data that is part of a tag (I.E. enclosed in '<>'). Args: data: The received data. app_data_buffer: The application level data buffer. Returns: The remaining data. \"\"\" app_data , separator , data = data . partition ( GT ) self . _tag_buffer . extend ( app_data ) if not separator : # End of tag not reached yet. return data tag : bytes = bytes ( self . _tag_buffer ) . strip () self . _tag_buffer . clear () tag_name : str = decode_bytes ( tag ) . strip ( \"/\" ) . split ( None , 1 )[ 0 ] if tag else \"\" is_closing_tag : bool = tag . startswith ( b \"/\" ) if self . output_format == \"raw\" : app_data_buffer . extend ( LT + tag + GT ) elif self . output_format == \"tintin\" and not self . _gratuitous : app_data_buffer . extend ( get_tintin_tag_replacement ( tag , self . tintin_replacements )) if tag_name == \"gratuitous\" : self . _gratuitous = not is_closing_tag elif is_closing_tag and get_xml_mode ( tag_name ) is self . _mode : # The tag is a closing tag, corresponding with the current mode. if self . _mode is XMLMode . ROOM : self . on_xml_event ( \"dynamic\" , unescape_xml_bytes ( bytes ( self . _dynamic_buffer ) . lstrip ( b \" \\r\\n \" ))) self . _dynamic_buffer . clear () else : self . on_xml_event ( tag_name , unescape_xml_bytes ( bytes ( self . _text_buffer ))) self . _text_buffer . clear () self . _mode = self . _parent_modes . pop () elif tag_name == \"magic\" : # Magic tags can occur inside and outside room info. self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . MAGIC elif self . _mode is XMLMode . NONE and tag_name == \"movement\" : # Movement is transmitted as a self-closing tag, I.E. opening and closing tag in one. # Because of this, we don't need a separate mode for movement. self . on_xml_event ( tag_name , direction_from_movement ( unescape_xml_bytes ( tag ))) elif self . _mode is XMLMode . NONE : # A new child mode from NONE. if tag_name == \"prompt\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . PROMPT elif tag_name == \"room\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . ROOM self . on_xml_event ( \"room\" , unescape_xml_bytes ( tag [ 5 :])) elif self . _mode is XMLMode . ROOM : # New child mode from ROOM. if tag_name == \"name\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . NAME elif tag_name == \"description\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . DESCRIPTION elif tag_name == \"exits\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . EXITS elif tag_name == \"terrain\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . TERRAIN self . state = XMLState . DATA return data def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 app_data_buffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handle_xml_text ( data , app_data_buffer ) elif self . state is XMLState . TAG : data = self . _handle_xml_tag ( data , app_data_buffer ) if app_data_buffer : if self . output_format == \"raw\" : super () . on_data_received ( bytes ( app_data_buffer )) else : super () . on_data_received ( unescape_xml_bytes ( bytes ( app_data_buffer ))) def on_connection_made ( self ) -> None : # NOQA: D102 # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous # tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) def on_connection_lost ( self ) -> None : # NOQA: D102 pass def on_xml_event ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\" Attribute is_client : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute is_server : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Attribute tintin_replacements : ClassVar [ set [ bytes ]] \u00b6 Tag to replacement values for Tintin. Method __init__ ( self , * args , * , output_format , ** kwargs ) special \u00b6 Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () output_format str The output format to be used. required **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/xml.py def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tag_buffer : bytearray = bytearray () # Used for start and end tag names. self . _text_buffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamic_buffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _line_buffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _mode : XMLMode = XMLMode . NONE self . _parent_modes : list [ XMLMode ] = [] Method on_connection_lost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/xml.py def on_connection_lost ( self ) -> None : # NOQA: D102 pass Method on_connection_made ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/xml.py def on_connection_made ( self ) -> None : # NOQA: D102 # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous # tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) Method on_data_received ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/xml.py def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 app_data_buffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handle_xml_text ( data , app_data_buffer ) elif self . state is XMLState . TAG : data = self . _handle_xml_tag ( data , app_data_buffer ) if app_data_buffer : if self . output_format == \"raw\" : super () . on_data_received ( bytes ( app_data_buffer )) else : super () . on_data_received ( unescape_xml_bytes ( bytes ( app_data_buffer ))) Method on_xml_event ( self , name , data ) \u00b6 Called when an XML event was received. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mudproto/xml.py def on_xml_event ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/xml.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data ) Class XMLState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/xml.py class XMLState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () TAG = auto () Function direction_from_movement ( movement ) \u00b6 Retrieves the direction of movement from a movement tag. Parameters: Name Type Description Default movement bytes The movement tag to parse. required Returns: Type Description bytes The direction of movement. Source code in mudproto/xml.py def direction_from_movement ( movement : bytes ) -> bytes : \"\"\" Retrieves the direction of movement from a movement tag. Args: movement: The movement tag to parse. Returns: The direction of movement. \"\"\" match : ReBytesMatchType = DIRECTIONS_REGEX . search ( movement ) return match . group ( \"dir\" ) if match is not None else b \"\" Function get_tintin_tag_replacement ( tag , valid_tags ) \u00b6 Retrieves a Tintin tag replacement from a tag name. Parameters: Name Type Description Default tag bytes The tag name. required valid_tags Iterable[bytes] The supported tag names. required Returns: Type Description bytes Uppercase tag name followed by a colon if opening tag, a colon followed by uppercase tag name if closing tag, An empty bytes object if not found. Source code in mudproto/xml.py def get_tintin_tag_replacement ( tag : bytes , valid_tags : Iterable [ bytes ]) -> bytes : \"\"\" Retrieves a Tintin tag replacement from a tag name. Args: tag: The tag name. valid_tags: The supported tag names. Returns: Uppercase tag name followed by a colon if opening tag, a colon followed by uppercase tag name if closing tag, An empty bytes object if not found. \"\"\" is_closing : bool = tag . startswith ( b \"/\" ) tag = tag . strip ( b \"/\" ) return b \"\" if tag not in valid_tags else b \":\" + tag . upper () if is_closing else tag . upper () + b \":\" Function get_xml_mode ( tag ) \u00b6 Retrieves an XMLMode enum from a tag name. Parameters: Name Type Description Default tag str The tag name. required Returns: Type Description Union[XMLMode, None] the XMLMode enum corresponding to the tag name, None if not found. Source code in mudproto/xml.py def get_xml_mode ( tag : str ) -> Union [ XMLMode , None ]: \"\"\" Retrieves an XMLMode enum from a tag name. Args: tag: The tag name. Returns: the XMLMode enum corresponding to the tag name, None if not found. \"\"\" with suppress ( KeyError ): return XMLMode [ tag . upper ()] return None","title":"xml.py"},{"location":"api/xml/#mudproto.xml","text":"Mume XML Protocol.","title":"xml"},{"location":"api/xml/#mudproto.xml.XMLMode","text":"Valid modes corresponding to supported XML tags. Source code in mudproto/xml.py class XMLMode ( Enum ): \"\"\"Valid modes corresponding to supported XML tags.\"\"\" NONE = auto () DESCRIPTION = auto () EXITS = auto () MAGIC = auto () NAME = auto () PROMPT = auto () ROOM = auto () TERRAIN = auto ()","title":"XMLMode"},{"location":"api/xml/#mudproto.xml.XMLProtocol","text":"Implements the Mume XML protocol. Source code in mudproto/xml.py class XMLProtocol ( ConnectionInterface ): \"\"\"Implements the Mume XML protocol.\"\"\" tintin_replacements : ClassVar [ set [ bytes ]] = { b \"prompt\" , b \"name\" , b \"tell\" , b \"narrate\" , b \"pray\" , b \"say\" , b \"emote\" , } \"\"\"Tag to replacement values for Tintin.\"\"\" def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tag_buffer : bytearray = bytearray () # Used for start and end tag names. self . _text_buffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamic_buffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _line_buffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _mode : XMLMode = XMLMode . NONE self . _parent_modes : list [ XMLMode ] = [] def _handle_xml_text ( self , data : bytes , app_data_buffer : bytearray ) -> bytes : \"\"\" Handles XML data that is not part of a tag. Args: data: The received data. app_data_buffer: The application level data buffer. Returns: The remaining data. \"\"\" app_data , separator , data = data . partition ( LT ) if self . output_format == \"raw\" or not self . _gratuitous : # Gratuitous text should be omitted unless format is 'raw'. app_data_buffer . extend ( app_data ) if self . _mode is XMLMode . NONE : self . _line_buffer . extend ( app_data ) lines = self . _line_buffer . splitlines ( keepends = True ) self . _line_buffer . clear () if lines and not lines [ - 1 ] . endswith (( CR , LF )): # Final line is incomplete. self . _line_buffer . extend ( lines . pop ()) for line in lines : if line . strip (): self . on_xml_event ( \"line\" , unescape_xml_bytes ( line . rstrip ( CR_LF ))) elif self . _mode is XMLMode . ROOM : self . _dynamic_buffer . extend ( app_data ) else : self . _text_buffer . extend ( app_data ) if separator : self . state = XMLState . TAG return data def _handle_xml_tag ( self , data : bytes , app_data_buffer : bytearray ) -> bytes : # NOQA: C901, PLR0912 \"\"\" Handles XML data that is part of a tag (I.E. enclosed in '<>'). Args: data: The received data. app_data_buffer: The application level data buffer. Returns: The remaining data. \"\"\" app_data , separator , data = data . partition ( GT ) self . _tag_buffer . extend ( app_data ) if not separator : # End of tag not reached yet. return data tag : bytes = bytes ( self . _tag_buffer ) . strip () self . _tag_buffer . clear () tag_name : str = decode_bytes ( tag ) . strip ( \"/\" ) . split ( None , 1 )[ 0 ] if tag else \"\" is_closing_tag : bool = tag . startswith ( b \"/\" ) if self . output_format == \"raw\" : app_data_buffer . extend ( LT + tag + GT ) elif self . output_format == \"tintin\" and not self . _gratuitous : app_data_buffer . extend ( get_tintin_tag_replacement ( tag , self . tintin_replacements )) if tag_name == \"gratuitous\" : self . _gratuitous = not is_closing_tag elif is_closing_tag and get_xml_mode ( tag_name ) is self . _mode : # The tag is a closing tag, corresponding with the current mode. if self . _mode is XMLMode . ROOM : self . on_xml_event ( \"dynamic\" , unescape_xml_bytes ( bytes ( self . _dynamic_buffer ) . lstrip ( b \" \\r\\n \" ))) self . _dynamic_buffer . clear () else : self . on_xml_event ( tag_name , unescape_xml_bytes ( bytes ( self . _text_buffer ))) self . _text_buffer . clear () self . _mode = self . _parent_modes . pop () elif tag_name == \"magic\" : # Magic tags can occur inside and outside room info. self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . MAGIC elif self . _mode is XMLMode . NONE and tag_name == \"movement\" : # Movement is transmitted as a self-closing tag, I.E. opening and closing tag in one. # Because of this, we don't need a separate mode for movement. self . on_xml_event ( tag_name , direction_from_movement ( unescape_xml_bytes ( tag ))) elif self . _mode is XMLMode . NONE : # A new child mode from NONE. if tag_name == \"prompt\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . PROMPT elif tag_name == \"room\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . ROOM self . on_xml_event ( \"room\" , unescape_xml_bytes ( tag [ 5 :])) elif self . _mode is XMLMode . ROOM : # New child mode from ROOM. if tag_name == \"name\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . NAME elif tag_name == \"description\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . DESCRIPTION elif tag_name == \"exits\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . EXITS elif tag_name == \"terrain\" : self . _parent_modes . append ( self . _mode ) self . _mode = XMLMode . TERRAIN self . state = XMLState . DATA return data def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 app_data_buffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handle_xml_text ( data , app_data_buffer ) elif self . state is XMLState . TAG : data = self . _handle_xml_tag ( data , app_data_buffer ) if app_data_buffer : if self . output_format == \"raw\" : super () . on_data_received ( bytes ( app_data_buffer )) else : super () . on_data_received ( unescape_xml_bytes ( bytes ( app_data_buffer ))) def on_connection_made ( self ) -> None : # NOQA: D102 # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous # tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) def on_connection_lost ( self ) -> None : # NOQA: D102 pass def on_xml_event ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\"","title":"XMLProtocol"},{"location":"api/xml/#mudproto.xml.XMLProtocol.is_client","text":"True if acting as a client, False otherwise.","title":"is_client"},{"location":"api/xml/#mudproto.xml.XMLProtocol.is_server","text":"True if acting as a server, False otherwise.","title":"is_server"},{"location":"api/xml/#mudproto.xml.XMLProtocol.tintin_replacements","text":"Tag to replacement values for Tintin.","title":"tintin_replacements"},{"location":"api/xml/#mudproto.xml.XMLProtocol.__init__","text":"Defines the constructor. Parameters: Name Type Description Default *args Any Positional arguments to be passed to the parent constructor. () output_format str The output format to be used. required **kwargs Any Key-word only arguments to be passed to the parent constructor. {} Source code in mudproto/xml.py def __init__ ( self , * args : Any , output_format : str , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor. Args: *args: Positional arguments to be passed to the parent constructor. output_format: The output format to be used. **kwargs: Key-word only arguments to be passed to the parent constructor. \"\"\" self . output_format : str = output_format super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tag_buffer : bytearray = bytearray () # Used for start and end tag names. self . _text_buffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamic_buffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _line_buffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _mode : XMLMode = XMLMode . NONE self . _parent_modes : list [ XMLMode ] = []","title":"__init__()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_connection_lost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/xml.py def on_connection_lost ( self ) -> None : # NOQA: D102 pass","title":"on_connection_lost()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_connection_made","text":"Called by connect when a connection to peer has been established. Source code in mudproto/xml.py def on_connection_made ( self ) -> None : # NOQA: D102 # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous # tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF )","title":"on_connection_made()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_data_received","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/xml.py def on_data_received ( self , data : bytes ) -> None : # NOQA: D102 app_data_buffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handle_xml_text ( data , app_data_buffer ) elif self . state is XMLState . TAG : data = self . _handle_xml_tag ( data , app_data_buffer ) if app_data_buffer : if self . output_format == \"raw\" : super () . on_data_received ( bytes ( app_data_buffer )) else : super () . on_data_received ( unescape_xml_bytes ( bytes ( app_data_buffer )))","title":"on_data_received()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_xml_event","text":"Called when an XML event was received. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mudproto/xml.py def on_xml_event ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\"","title":"on_xml_event()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/xml.py def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" self . _writer ( data )","title":"write()"},{"location":"api/xml/#mudproto.xml.XMLState","text":"Valid states for the state machine. Source code in mudproto/xml.py class XMLState ( Enum ): \"\"\"Valid states for the state machine.\"\"\" DATA = auto () TAG = auto ()","title":"XMLState"},{"location":"api/xml/#mudproto.xml.direction_from_movement","text":"Retrieves the direction of movement from a movement tag. Parameters: Name Type Description Default movement bytes The movement tag to parse. required Returns: Type Description bytes The direction of movement. Source code in mudproto/xml.py def direction_from_movement ( movement : bytes ) -> bytes : \"\"\" Retrieves the direction of movement from a movement tag. Args: movement: The movement tag to parse. Returns: The direction of movement. \"\"\" match : ReBytesMatchType = DIRECTIONS_REGEX . search ( movement ) return match . group ( \"dir\" ) if match is not None else b \"\"","title":"direction_from_movement()"},{"location":"api/xml/#mudproto.xml.get_tintin_tag_replacement","text":"Retrieves a Tintin tag replacement from a tag name. Parameters: Name Type Description Default tag bytes The tag name. required valid_tags Iterable[bytes] The supported tag names. required Returns: Type Description bytes Uppercase tag name followed by a colon if opening tag, a colon followed by uppercase tag name if closing tag, An empty bytes object if not found. Source code in mudproto/xml.py def get_tintin_tag_replacement ( tag : bytes , valid_tags : Iterable [ bytes ]) -> bytes : \"\"\" Retrieves a Tintin tag replacement from a tag name. Args: tag: The tag name. valid_tags: The supported tag names. Returns: Uppercase tag name followed by a colon if opening tag, a colon followed by uppercase tag name if closing tag, An empty bytes object if not found. \"\"\" is_closing : bool = tag . startswith ( b \"/\" ) tag = tag . strip ( b \"/\" ) return b \"\" if tag not in valid_tags else b \":\" + tag . upper () if is_closing else tag . upper () + b \":\"","title":"get_tintin_tag_replacement()"},{"location":"api/xml/#mudproto.xml.get_xml_mode","text":"Retrieves an XMLMode enum from a tag name. Parameters: Name Type Description Default tag str The tag name. required Returns: Type Description Union[XMLMode, None] the XMLMode enum corresponding to the tag name, None if not found. Source code in mudproto/xml.py def get_xml_mode ( tag : str ) -> Union [ XMLMode , None ]: \"\"\" Retrieves an XMLMode enum from a tag name. Args: tag: The tag name. Returns: the XMLMode enum corresponding to the tag name, None if not found. \"\"\" with suppress ( KeyError ): return XMLMode [ tag . upper ()] return None","title":"get_xml_mode()"}]}