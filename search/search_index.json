{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"Mozilla Public License Version 2.0 \u00b6 1. Definitions \u00b6 1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions \u00b6 2.1. Grants \u00b6 Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date \u00b6 The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope \u00b6 The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses \u00b6 No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation \u00b6 Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use \u00b6 This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions \u00b6 Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities \u00b6 3.1. Distribution of Source Form \u00b6 All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form \u00b6 If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work \u00b6 You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices \u00b6 You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms \u00b6 You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation \u00b6 If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination \u00b6 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. 6. Disclaimer of Warranty \u00b6 Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer. 7. Limitation of Liability \u00b6 Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You. 8. Litigation \u00b6 Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous \u00b6 This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License \u00b6 10.1. New Versions \u00b6 Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions \u00b6 You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions \u00b6 If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses \u00b6 If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice \u00b6 This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice \u00b6 This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"license/#1-definitions","text":"1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"license/#2-license-grants-and-conditions","text":"","title":"2. License Grants and Conditions"},{"location":"license/#21-grants","text":"Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.","title":"2.1. Grants"},{"location":"license/#22-effective-date","text":"The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.","title":"2.2. Effective Date"},{"location":"license/#23-limitations-on-grant-scope","text":"The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).","title":"2.3. Limitations on Grant Scope"},{"location":"license/#24-subsequent-licenses","text":"No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).","title":"2.4. Subsequent Licenses"},{"location":"license/#25-representation","text":"Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.","title":"2.5. Representation"},{"location":"license/#26-fair-use","text":"This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.","title":"2.6. Fair Use"},{"location":"license/#27-conditions","text":"Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2.7. Conditions"},{"location":"license/#3-responsibilities","text":"","title":"3. Responsibilities"},{"location":"license/#31-distribution-of-source-form","text":"All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.","title":"3.1. Distribution of Source Form"},{"location":"license/#32-distribution-of-executable-form","text":"If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License.","title":"3.2. Distribution of Executable Form"},{"location":"license/#33-distribution-of-a-larger-work","text":"You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).","title":"3.3. Distribution of a Larger Work"},{"location":"license/#34-notices","text":"You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.","title":"3.4. Notices"},{"location":"license/#35-application-of-additional-terms","text":"You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3.5. Application of Additional Terms"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.","title":"5. Termination"},{"location":"license/#6-disclaimer-of-warranty","text":"Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.","title":"6. Disclaimer of Warranty"},{"location":"license/#7-limitation-of-liability","text":"Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.","title":"7. Limitation of Liability"},{"location":"license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"license/#10-versions-of-the-license","text":"","title":"10. Versions of the License"},{"location":"license/#101-new-versions","text":"Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.","title":"10.1. New Versions"},{"location":"license/#102-effect-of-new-versions","text":"You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.","title":"10.2. Effect of New Versions"},{"location":"license/#103-modified-versions","text":"If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).","title":"10.3. Modified Versions"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","text":"If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses"},{"location":"license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice"},{"location":"api/","text":"MUD Protocols API \u00b6 Automatically generated API reference. MUD Protocols \u00b6 Base Protocol Charset Protocol Protocol Manager MUD Client Compression Protocol MUME Protocol Initiator Telnet Protocol Misc Utilities MUME XML Protocol","title":"API Index"},{"location":"api/#mud-protocols-api","text":"Automatically generated API reference.","title":"MUD Protocols API"},{"location":"api/#mud-protocols","text":"Base Protocol Charset Protocol Protocol Manager MUD Client Compression Protocol MUME Protocol Initiator Telnet Protocol Misc Utilities MUME XML Protocol","title":"MUD Protocols"},{"location":"api/base/","text":"Module mudproto.base \u00b6 Class BaseProtocol( Protocol ) \u00b6 Source code in mudproto/base.py class BaseProtocol ( TypeProtocol ): @property @abstractmethod def isClient ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" @property @abstractmethod def isServer ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" Attribute isClient : bool property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool property readonly \u00b6 True if acting as a server, False otherwise. Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/base.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/base.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/base.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" Method write ( self , data ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/base.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" Class Protocol( BaseProtocol ) \u00b6 Source code in mudproto/base.py class Protocol ( BaseProtocol ): def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , ** kwargs : Any , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient @property def isClient ( self ) -> bool : return self . _isClient @property def isServer ( self ) -> bool : return not self . _isClient def write ( self , data : bytes ) -> None : self . _writer ( data ) def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data ) Attribute isClient : bool property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , writer , receiver , * , isClient , ** kwargs ) special \u00b6 Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/base.py def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , ** kwargs : Any , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/base.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/base.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/base.py def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data ) Method write ( self , data ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/base.py def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"base.py"},{"location":"api/base/#mudproto.base","text":"","title":"base"},{"location":"api/base/#mudproto.base.BaseProtocol","text":"Source code in mudproto/base.py class BaseProtocol ( TypeProtocol ): @property @abstractmethod def isClient ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" @property @abstractmethod def isServer ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\"","title":"BaseProtocol"},{"location":"api/base/#mudproto.base.BaseProtocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/base/#mudproto.base.BaseProtocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/base/#mudproto.base.BaseProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/base.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/base/#mudproto.base.BaseProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/base.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/base/#mudproto.base.BaseProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/base.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\"","title":"on_dataReceived()"},{"location":"api/base/#mudproto.base.BaseProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/base.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"write()"},{"location":"api/base/#mudproto.base.Protocol","text":"Source code in mudproto/base.py class Protocol ( BaseProtocol ): def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , ** kwargs : Any , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient @property def isClient ( self ) -> bool : return self . _isClient @property def isServer ( self ) -> bool : return not self . _isClient def write ( self , data : bytes ) -> None : self . _writer ( data ) def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data )","title":"Protocol"},{"location":"api/base/#mudproto.base.Protocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/base/#mudproto.base.Protocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/base/#mudproto.base.Protocol.__init__","text":"Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/base.py def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , ** kwargs : Any , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient","title":"__init__()"},{"location":"api/base/#mudproto.base.Protocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/base.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/base/#mudproto.base.Protocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/base.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/base/#mudproto.base.Protocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/base.py def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data )","title":"on_dataReceived()"},{"location":"api/base/#mudproto.base.Protocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/base.py def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/charset/","text":"Module mudproto.charset \u00b6 Charset protocol. Class CharsetMixIn( BaseTelnetProtocol ) \u00b6 A charset mix in class for the Telnet protocol. Source code in mudproto/charset.py class CharsetMixIn ( Base ): \"\"\"A charset mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] @property def charset ( self ) -> bytes : \"\"\"The character set to be used.\"\"\" return self . _charset @charset . setter def charset ( self , value : bytes ) -> None : value = value . upper () if value not in self . _charsets : raise ValueError ( f \"' { value !r} ' not in { self . _charsets !r} \" ) self . _charset = value def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) else : logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name ) def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : separator , response = response [: 1 ], response [ 1 :] . upper () self . _charsets = tuple ( response . split ( separator )) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiateCharset ( self . charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enableLocal ( option )) # pragma: no cover def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return None super () . on_disableLocal ( option ) # pragma: no cover Attribute charset : bytes property writable \u00b6 The character set to be used. Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , * args , ** kwargs ) special \u00b6 Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/charset.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/charset.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/charset.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method getOptionState ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/charset.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method negotiateCharset ( self , name ) \u00b6 Negotiates changing the character set. Parameters: Name Type Description Default name bytes The name of the character set to use. required Source code in mudproto/charset.py def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) else : logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name ) Method on_charset ( self , data ) \u00b6 Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mudproto/charset.py def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : separator , response = response [: 1 ], response [ 1 :] . upper () self . _charsets = tuple ( response . split ( separator )) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiateCharset ( self . charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/charset.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/charset.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/charset.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return None super () . on_disableLocal ( option ) # pragma: no cover Method on_disableRemote ( self , option ) inherited \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/charset.py def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enableLocal ( option )) # pragma: no cover Method on_enableRemote ( self , option ) inherited \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/charset.py @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" Method on_optionEnabled ( self , option ) inherited \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/charset.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandledCommand ( self , command , option ) inherited \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandledSubnegotiation ( self , option , data ) inherited \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method requestNegotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/charset.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/charset.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/charset.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"charset.py"},{"location":"api/charset/#mudproto.charset","text":"Charset protocol.","title":"charset"},{"location":"api/charset/#mudproto.charset.CharsetMixIn","text":"A charset mix in class for the Telnet protocol. Source code in mudproto/charset.py class CharsetMixIn ( Base ): \"\"\"A charset mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ] @property def charset ( self ) -> bytes : \"\"\"The character set to be used.\"\"\" return self . _charset @charset . setter def charset ( self , value : bytes ) -> None : value = value . upper () if value not in self . _charsets : raise ValueError ( f \"' { value !r} ' not in { self . _charsets !r} \" ) self . _charset = value def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) else : logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name ) def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : separator , response = response [: 1 ], response [ 1 :] . upper () self . _charsets = tuple ( response . split ( separator )) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiateCharset ( self . charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET ) def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enableLocal ( option )) # pragma: no cover def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return None super () . on_disableLocal ( option ) # pragma: no cover","title":"CharsetMixIn"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.charset","text":"The character set to be used.","title":"charset"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.__init__","text":"Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/charset.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ CHARSET ] = self . on_charset self . _charsets : tuple [ bytes , ... ] = ( b \"US-ASCII\" ,) self . _charset : bytes = self . _charsets [ 0 ]","title":"__init__()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/charset.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/charset.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.getOptionState","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/charset.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"getOptionState()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.negotiateCharset","text":"Negotiates changing the character set. Parameters: Name Type Description Default name bytes The name of the character set to use. required Source code in mudproto/charset.py def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" separator : bytes = b \";\" try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) else : logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name )","title":"negotiateCharset()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_charset","text":"Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mudproto/charset.py def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_REQUEST : separator , response = response [: 1 ], response [ 1 :] . upper () self . _charsets = tuple ( response . split ( separator )) logger . debug ( f \"Peer responds: Supported charsets: { self . _charsets !r} .\" ) self . negotiateCharset ( self . charset ) elif status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) self . charset = response elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . wont ( CHARSET )","title":"on_charset()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/charset.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/charset.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/charset.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\"","title":"on_dataReceived()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : logger . debug ( \"Charset negotiation disabled.\" ) return None super () . on_disableLocal ( option ) # pragma: no cover","title":"on_disableLocal()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/charset.py @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableRemote()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/charset.py def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Charset negotiation enabled.\" ) return True return bool ( super () . on_enableLocal ( option )) # pragma: no cover","title":"on_enableLocal()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/charset.py @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\"","title":"on_enableRemote()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_optionEnabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/charset.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_optionEnabled()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/charset.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandledCommand()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandledSubnegotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/charset.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"requestNegotiation()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/charset.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/charset.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/charset/#mudproto.charset.CharsetMixIn.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/charset.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"write()"},{"location":"api/manager/","text":"Module mudproto.manager \u00b6 Class Manager \u00b6 Source code in mudproto/manager.py class Manager ( object ): def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , promptTerminator : Optional [ bytes ] = None , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient self . promptTerminator : bytes if promptTerminator is None : self . promptTerminator = IAC + GA else : self . promptTerminator = ( promptTerminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _readBuffer : bytearray = bytearray () self . _writeBuffer : bytearray = bytearray () self . _handlers : list [ Protocol ] = [] self . _isConnected : bool = False @property def isClient ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _isClient @property def isServer ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _isClient @property def isConnected ( self ) -> bool : \"\"\"Connection status.\"\"\" return self . _isConnected def __enter__ ( self ) -> Manager : self . connect () return self def __exit__ ( self , excType : Optional [ type [ BaseException ]], excValue : Optional [ BaseException ], excTraceback : Optional [ TracebackType ], ) -> None : self . disconnect () def __del__ ( self ) -> None : self . disconnect () def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = bytes ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = bytes ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data ) def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . extend ( data ) return None elif self . _readBuffer : data = bytes ( self . _readBuffer + data ) self . _readBuffer . clear () if data : self . _handlers [ 0 ] . on_dataReceived ( data ) def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escapeIAC ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . promptTerminator if not self . isConnected or not self . _handlers : self . _writeBuffer . extend ( data ) return None elif self . _writeBuffer : data = bytes ( self . _writeBuffer + data ) self . _writeBuffer . clear () if data : self . _writer ( data ) def register ( self , handler : type [ Protocol ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( self . write , self . _receiver , isClient = self . _isClient , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade () def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost () Attribute isClient : bool property readonly \u00b6 True if acting as a client, False otherwise. Attribute isConnected : bool property readonly \u00b6 Connection status. Attribute isServer : bool property readonly \u00b6 True if acting as a server, False otherwise. Method close ( self ) \u00b6 Calls disconnect . Source code in mudproto/manager.py def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () Method connect ( self ) \u00b6 Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mudproto/manager.py def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = bytes ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = bytes ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data ) Method disconnect ( self ) \u00b6 Signals that peer has disconnected. Source code in mudproto/manager.py def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False Method parse ( self , data ) \u00b6 Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mudproto/manager.py def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . extend ( data ) return None elif self . _readBuffer : data = bytes ( self . _readBuffer + data ) self . _readBuffer . clear () if data : self . _handlers [ 0 ] . on_dataReceived ( data ) Method register ( self , handler , ** kwargs ) \u00b6 Registers a protocol handler. Parameters: Name Type Description Default handler type[Protocol] The handler to be registered. required **kwargs Any Key word arguments to be passed to the handler's constructer. {} Source code in mudproto/manager.py def register ( self , handler : type [ Protocol ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( self . write , self . _receiver , isClient = self . _isClient , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade () Method unregister ( self , instance ) \u00b6 Unregisters a protocol handler. Parameters: Name Type Description Default instance Protocol The handler instance to be unregistered. required Source code in mudproto/manager.py def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost () Method write ( self , data , * , escape = False , prompt = False ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If True, escapes line endings and IAC characters. False prompt bool If True, appends the prompt terminator to the data. False Source code in mudproto/manager.py def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escapeIAC ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . promptTerminator if not self . isConnected or not self . _handlers : self . _writeBuffer . extend ( data ) return None elif self . _writeBuffer : data = bytes ( self . _writeBuffer + data ) self . _writeBuffer . clear () if data : self . _writer ( data )","title":"manager.py"},{"location":"api/manager/#mudproto.manager","text":"","title":"manager"},{"location":"api/manager/#mudproto.manager.Manager","text":"Source code in mudproto/manager.py class Manager ( object ): def __init__ ( self , writer : PROTOCOL_WRITER_TYPE , receiver : PROTOCOL_RECEIVER_TYPE , * , isClient : bool , promptTerminator : Optional [ bytes ] = None , ) -> None : self . _writer : PROTOCOL_WRITER_TYPE = writer self . _receiver : PROTOCOL_RECEIVER_TYPE = receiver self . _isClient : bool = isClient self . promptTerminator : bytes if promptTerminator is None : self . promptTerminator = IAC + GA else : self . promptTerminator = ( promptTerminator . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) self . _readBuffer : bytearray = bytearray () self . _writeBuffer : bytearray = bytearray () self . _handlers : list [ Protocol ] = [] self . _isConnected : bool = False @property def isClient ( self ) -> bool : \"\"\"True if acting as a client, False otherwise.\"\"\" return self . _isClient @property def isServer ( self ) -> bool : \"\"\"True if acting as a server, False otherwise.\"\"\" return not self . _isClient @property def isConnected ( self ) -> bool : \"\"\"Connection status.\"\"\" return self . _isConnected def __enter__ ( self ) -> Manager : self . connect () return self def __exit__ ( self , excType : Optional [ type [ BaseException ]], excValue : Optional [ BaseException ], excTraceback : Optional [ TracebackType ], ) -> None : self . disconnect () def __del__ ( self ) -> None : self . disconnect () def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = bytes ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = bytes ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data ) def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . extend ( data ) return None elif self . _readBuffer : data = bytes ( self . _readBuffer + data ) self . _readBuffer . clear () if data : self . _handlers [ 0 ] . on_dataReceived ( data ) def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escapeIAC ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . promptTerminator if not self . isConnected or not self . _handlers : self . _writeBuffer . extend ( data ) return None elif self . _writeBuffer : data = bytes ( self . _writeBuffer + data ) self . _writeBuffer . clear () if data : self . _writer ( data ) def register ( self , handler : type [ Protocol ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( self . write , self . _receiver , isClient = self . _isClient , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade () def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost ()","title":"Manager"},{"location":"api/manager/#mudproto.manager.Manager.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/manager/#mudproto.manager.Manager.isConnected","text":"Connection status.","title":"isConnected"},{"location":"api/manager/#mudproto.manager.Manager.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/manager/#mudproto.manager.Manager.close","text":"Calls disconnect . Source code in mudproto/manager.py def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect ()","title":"close()"},{"location":"api/manager/#mudproto.manager.Manager.connect","text":"Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mudproto/manager.py def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" data : bytes if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = bytes ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = bytes ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data )","title":"connect()"},{"location":"api/manager/#mudproto.manager.Manager.disconnect","text":"Signals that peer has disconnected. Source code in mudproto/manager.py def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False","title":"disconnect()"},{"location":"api/manager/#mudproto.manager.Manager.parse","text":"Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mudproto/manager.py def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . extend ( data ) return None elif self . _readBuffer : data = bytes ( self . _readBuffer + data ) self . _readBuffer . clear () if data : self . _handlers [ 0 ] . on_dataReceived ( data )","title":"parse()"},{"location":"api/manager/#mudproto.manager.Manager.register","text":"Registers a protocol handler. Parameters: Name Type Description Default handler type[Protocol] The handler to be registered. required **kwargs Any Key word arguments to be passed to the handler's constructer. {} Source code in mudproto/manager.py def register ( self , handler : type [ Protocol ], ** kwargs : Any ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( self . write , self . _receiver , isClient = self . _isClient , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade ()","title":"register()"},{"location":"api/manager/#mudproto.manager.Manager.unregister","text":"Unregisters a protocol handler. Parameters: Name Type Description Default instance Protocol The handler instance to be unregistered. required Source code in mudproto/manager.py def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost ()","title":"unregister()"},{"location":"api/manager/#mudproto.manager.Manager.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If True, escapes line endings and IAC characters. False prompt bool If True, appends the prompt terminator to the data. False Source code in mudproto/manager.py def write ( self , data : bytes , * , escape : bool = False , prompt : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If True, escapes line endings and IAC characters. prompt: If True, appends the prompt terminator to the data. \"\"\" if escape : data = escapeIAC ( data ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) if prompt : data += self . promptTerminator if not self . isConnected or not self . _handlers : self . _writeBuffer . extend ( data ) return None elif self . _writeBuffer : data = bytes ( self . _writeBuffer + data ) self . _writeBuffer . clear () if data : self . _writer ( data )","title":"write()"},{"location":"api/mccp/","text":"Module mudproto.mccp \u00b6 MUD Client Compression protocol. Class MCCPMixIn( BaseTelnetProtocol ) \u00b6 An MCCP mix in class for the Telnet protocol. Source code in mudproto/mccp.py class MCCPMixIn ( Base ): \"\"\"An MCCP mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ MCCP1 ] = lambda * args : None self . subnegotiationMap [ MCCP2 ] = lambda * args : None self . _compressionEnabled : bool = False self . _mccpVersion : Union [ int , None ] = None self . _compressedInputBuffer : bytearray = bytearray () self . _decompressor : Any = None def disableMCCP ( self ) -> None : self . _mccpVersion = None self . _compressionEnabled = False self . _decompressor = None def on_dataReceived ( self , data : bytes ) -> None : inputBuffer : bytearray = self . _compressedInputBuffer inputBuffer . extend ( data ) while inputBuffer : if self . _compressionEnabled : # Compressed data: super () . on_dataReceived ( self . _decompressor . decompress ( inputBuffer )) inputBuffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data, likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) inputBuffer . extend ( self . _decompressor . unused_data ) state = self . getOptionState ( MCCP1 if self . _mccpVersion == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disableMCCP () continue # Process the remaining uncompressed data. return None # inputBuffer is empty, no need to loop again. # Uncompressed data: iacIndex : int = inputBuffer . find ( IAC ) if self . _mccpVersion is not None and iacIndex >= 0 : # MCCP was negotiated on, and an IAC byte was found. if iacIndex > 0 : super () . on_dataReceived ( bytes ( inputBuffer [: iacIndex ])) del inputBuffer [: iacIndex ] if len ( inputBuffer ) == 1 : # Partial IAC sequence. return None elif inputBuffer [ 1 ] == SB [ 0 ]: seIndex : int = inputBuffer . find ( SE ) if seIndex < 0 or inputBuffer [ seIndex - 1 : seIndex ] not in ( IAC , WILL ): # Partial subnegotiation sequence. return None elif inputBuffer [: seIndex ] in ( IAC + SB + MCCP1 + WILL , IAC + SB + MCCP2 + IAC ): # The server enabled compression. Subsequent data will be compressed. self . _compressionEnabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: seIndex + 1 ])) del inputBuffer [: seIndex + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: 2 ])) del inputBuffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_dataReceived ( bytes ( inputBuffer )) inputBuffer . clear () def on_enableRemote ( self , option : bytes ) -> bool : if option in ( MCCP1 , MCCP2 ): if self . _mccpVersion is None : self . _mccpVersion = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccpVersion } negotiation enabled.\" ) return True return False return bool ( super () . on_enableRemote ( option )) # pragma: no cover def on_disableRemote ( self , option : bytes ) -> None : if option in ( MCCP1 , MCCP2 ): logger . debug ( f \"MCCP { self . _mccpVersion if self . _mccpVersion is not None else '' } negotiation disabled.\" ) self . disableMCCP () return None super () . on_disableRemote ( option ) # pragma: no cover Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method __init__ ( self , * args , ** kwargs ) special \u00b6 Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/mccp.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ MCCP1 ] = lambda * args : None self . subnegotiationMap [ MCCP2 ] = lambda * args : None self . _compressionEnabled : bool = False self . _mccpVersion : Union [ int , None ] = None self . _compressedInputBuffer : bytearray = bytearray () self . _decompressor : Any = None Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/mccp.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/mccp.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method getOptionState ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/mccp.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/mccp.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/mccp.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mccp.py def on_dataReceived ( self , data : bytes ) -> None : inputBuffer : bytearray = self . _compressedInputBuffer inputBuffer . extend ( data ) while inputBuffer : if self . _compressionEnabled : # Compressed data: super () . on_dataReceived ( self . _decompressor . decompress ( inputBuffer )) inputBuffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data, likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) inputBuffer . extend ( self . _decompressor . unused_data ) state = self . getOptionState ( MCCP1 if self . _mccpVersion == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disableMCCP () continue # Process the remaining uncompressed data. return None # inputBuffer is empty, no need to loop again. # Uncompressed data: iacIndex : int = inputBuffer . find ( IAC ) if self . _mccpVersion is not None and iacIndex >= 0 : # MCCP was negotiated on, and an IAC byte was found. if iacIndex > 0 : super () . on_dataReceived ( bytes ( inputBuffer [: iacIndex ])) del inputBuffer [: iacIndex ] if len ( inputBuffer ) == 1 : # Partial IAC sequence. return None elif inputBuffer [ 1 ] == SB [ 0 ]: seIndex : int = inputBuffer . find ( SE ) if seIndex < 0 or inputBuffer [ seIndex - 1 : seIndex ] not in ( IAC , WILL ): # Partial subnegotiation sequence. return None elif inputBuffer [: seIndex ] in ( IAC + SB + MCCP1 + WILL , IAC + SB + MCCP2 + IAC ): # The server enabled compression. Subsequent data will be compressed. self . _compressionEnabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: seIndex + 1 ])) del inputBuffer [: seIndex + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: 2 ])) del inputBuffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_dataReceived ( bytes ( inputBuffer )) inputBuffer . clear () Method on_disableLocal ( self , option ) inherited \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_disableRemote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py def on_disableRemote ( self , option : bytes ) -> None : if option in ( MCCP1 , MCCP2 ): logger . debug ( f \"MCCP { self . _mccpVersion if self . _mccpVersion is not None else '' } negotiation disabled.\" ) self . disableMCCP () return None super () . on_disableRemote ( option ) # pragma: no cover Method on_enableLocal ( self , option ) inherited \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/mccp.py @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" Method on_enableRemote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/mccp.py def on_enableRemote ( self , option : bytes ) -> bool : if option in ( MCCP1 , MCCP2 ): if self . _mccpVersion is None : self . _mccpVersion = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccpVersion } negotiation enabled.\" ) return True return False return bool ( super () . on_enableRemote ( option )) # pragma: no cover Method on_optionEnabled ( self , option ) inherited \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/mccp.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandledCommand ( self , command , option ) inherited \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandledSubnegotiation ( self , option , data ) inherited \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method requestNegotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/mccp.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/mccp.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mccp.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"mccp.py"},{"location":"api/mccp/#mudproto.mccp","text":"MUD Client Compression protocol.","title":"mccp"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn","text":"An MCCP mix in class for the Telnet protocol. Source code in mudproto/mccp.py class MCCPMixIn ( Base ): \"\"\"An MCCP mix in class for the Telnet protocol.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ MCCP1 ] = lambda * args : None self . subnegotiationMap [ MCCP2 ] = lambda * args : None self . _compressionEnabled : bool = False self . _mccpVersion : Union [ int , None ] = None self . _compressedInputBuffer : bytearray = bytearray () self . _decompressor : Any = None def disableMCCP ( self ) -> None : self . _mccpVersion = None self . _compressionEnabled = False self . _decompressor = None def on_dataReceived ( self , data : bytes ) -> None : inputBuffer : bytearray = self . _compressedInputBuffer inputBuffer . extend ( data ) while inputBuffer : if self . _compressionEnabled : # Compressed data: super () . on_dataReceived ( self . _decompressor . decompress ( inputBuffer )) inputBuffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data, likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) inputBuffer . extend ( self . _decompressor . unused_data ) state = self . getOptionState ( MCCP1 if self . _mccpVersion == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disableMCCP () continue # Process the remaining uncompressed data. return None # inputBuffer is empty, no need to loop again. # Uncompressed data: iacIndex : int = inputBuffer . find ( IAC ) if self . _mccpVersion is not None and iacIndex >= 0 : # MCCP was negotiated on, and an IAC byte was found. if iacIndex > 0 : super () . on_dataReceived ( bytes ( inputBuffer [: iacIndex ])) del inputBuffer [: iacIndex ] if len ( inputBuffer ) == 1 : # Partial IAC sequence. return None elif inputBuffer [ 1 ] == SB [ 0 ]: seIndex : int = inputBuffer . find ( SE ) if seIndex < 0 or inputBuffer [ seIndex - 1 : seIndex ] not in ( IAC , WILL ): # Partial subnegotiation sequence. return None elif inputBuffer [: seIndex ] in ( IAC + SB + MCCP1 + WILL , IAC + SB + MCCP2 + IAC ): # The server enabled compression. Subsequent data will be compressed. self . _compressionEnabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: seIndex + 1 ])) del inputBuffer [: seIndex + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: 2 ])) del inputBuffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_dataReceived ( bytes ( inputBuffer )) inputBuffer . clear () def on_enableRemote ( self , option : bytes ) -> bool : if option in ( MCCP1 , MCCP2 ): if self . _mccpVersion is None : self . _mccpVersion = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccpVersion } negotiation enabled.\" ) return True return False return bool ( super () . on_enableRemote ( option )) # pragma: no cover def on_disableRemote ( self , option : bytes ) -> None : if option in ( MCCP1 , MCCP2 ): logger . debug ( f \"MCCP { self . _mccpVersion if self . _mccpVersion is not None else '' } negotiation disabled.\" ) self . disableMCCP () return None super () . on_disableRemote ( option ) # pragma: no cover","title":"MCCPMixIn"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.__init__","text":"Initialize self. See help(type(self)) for accurate signature. Source code in mudproto/mccp.py def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . subnegotiationMap [ MCCP1 ] = lambda * args : None self . subnegotiationMap [ MCCP2 ] = lambda * args : None self . _compressionEnabled : bool = False self . _mccpVersion : Union [ int , None ] = None self . _compressedInputBuffer : bytearray = bytearray () self . _decompressor : Any = None","title":"__init__()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/mccp.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/mccp.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.getOptionState","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/mccp.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"getOptionState()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/mccp.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/mccp.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mccp.py def on_dataReceived ( self , data : bytes ) -> None : inputBuffer : bytearray = self . _compressedInputBuffer inputBuffer . extend ( data ) while inputBuffer : if self . _compressionEnabled : # Compressed data: super () . on_dataReceived ( self . _decompressor . decompress ( inputBuffer )) inputBuffer . clear () if self . _decompressor . unused_data : # Uncompressed data following the compressed data, likely due to the server terminating compression. logger . debug ( \"received uncompressed data while compression enabled. Disabling compression.\" ) inputBuffer . extend ( self . _decompressor . unused_data ) state = self . getOptionState ( MCCP1 if self . _mccpVersion == 1 else MCCP2 ) state . him . enabled = False state . him . negotiating = False self . disableMCCP () continue # Process the remaining uncompressed data. return None # inputBuffer is empty, no need to loop again. # Uncompressed data: iacIndex : int = inputBuffer . find ( IAC ) if self . _mccpVersion is not None and iacIndex >= 0 : # MCCP was negotiated on, and an IAC byte was found. if iacIndex > 0 : super () . on_dataReceived ( bytes ( inputBuffer [: iacIndex ])) del inputBuffer [: iacIndex ] if len ( inputBuffer ) == 1 : # Partial IAC sequence. return None elif inputBuffer [ 1 ] == SB [ 0 ]: seIndex : int = inputBuffer . find ( SE ) if seIndex < 0 or inputBuffer [ seIndex - 1 : seIndex ] not in ( IAC , WILL ): # Partial subnegotiation sequence. return None elif inputBuffer [: seIndex ] in ( IAC + SB + MCCP1 + WILL , IAC + SB + MCCP2 + IAC ): # The server enabled compression. Subsequent data will be compressed. self . _compressionEnabled = True self . _decompressor = zlib . decompressobj ( zlib . MAX_WBITS ) logger . debug ( \"Peer notifies us that subsequent data will be compressed.\" ) else : # We don't care about other subnegotiations, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: seIndex + 1 ])) del inputBuffer [: seIndex + 1 ] else : # We don't care about other IAC sequences, pass it on. super () . on_dataReceived ( bytes ( inputBuffer [: 2 ])) del inputBuffer [: 2 ] else : # MCCP was not negotiated on, or no IAC was found. super () . on_dataReceived ( bytes ( inputBuffer )) inputBuffer . clear ()","title":"on_dataReceived()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableLocal()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/mccp.py def on_disableRemote ( self , option : bytes ) -> None : if option in ( MCCP1 , MCCP2 ): logger . debug ( f \"MCCP { self . _mccpVersion if self . _mccpVersion is not None else '' } negotiation disabled.\" ) self . disableMCCP () return None super () . on_disableRemote ( option ) # pragma: no cover","title":"on_disableRemote()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/mccp.py @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\"","title":"on_enableLocal()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/mccp.py def on_enableRemote ( self , option : bytes ) -> bool : if option in ( MCCP1 , MCCP2 ): if self . _mccpVersion is None : self . _mccpVersion = 1 if option == MCCP1 else 2 logger . debug ( f \"MCCP { self . _mccpVersion } negotiation enabled.\" ) return True return False return bool ( super () . on_enableRemote ( option )) # pragma: no cover","title":"on_enableRemote()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_optionEnabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/mccp.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_optionEnabled()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/mccp.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandledCommand()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandledSubnegotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/mccp.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"requestNegotiation()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/mccp.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/mccp.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/mccp/#mudproto.mccp.MCCPMixIn.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mccp.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"write()"},{"location":"api/mpi/","text":"Module mudproto.mpi \u00b6 Mume Remote Editing Protocol. Class MPIProtocol( Protocol ) \u00b6 Implements support for the Mume remote editing protocol. Attributes: Name Type Description commandMap MPI_COMMAND_MAP_TYPE A mapping of bytes to callables. editor str The program to use for editing received text. pager str The program to use for viewing received read-only text. Source code in mudproto/mpi.py class MPIProtocol ( Protocol ): \"\"\" Implements support for the Mume remote editing protocol. Attributes: commandMap: A mapping of bytes to callables. editor: The program to use for editing received text. pager: The program to use for viewing received read-only text. \"\"\" def __init__ ( self , * args : Any , outputFormat : str , ** kwargs : Any ) -> None : self . outputFormat : str = outputFormat super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _MPIBuffer : bytearray = bytearray () self . _MPIThreads : list [ threading . Thread ] = [] self . commandMap : MPI_COMMAND_MAP_TYPE = { b \"E\" : self . edit , b \"V\" : self . view , } editors : dict [ str , str ] = { \"win32\" : \"notepad\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad\" , } defaultEditor : str = editors . get ( sys . platform , \"nano\" ) defaultPager : str = pagers . get ( sys . platform , \"less\" ) self . editor : str = os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , defaultEditor ) self . pager : str = os . getenv ( \"PAGER\" , defaultPager ) self . _isWordWrapping : bool = False @property def isWordWrapping ( self ) -> bool : \"\"\"Specifies whether text should be word wrapped during editing or not.\"\"\" return self . _isWordWrapping @isWordWrapping . setter def isWordWrapping ( self , value : bool ) -> None : self . _isWordWrapping = value def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as tempFileObj : fileName = tempFileObj . name tempFileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : if self . isWordWrapping : with open ( fileName , \"r\" ) as textFileObj : text : str = str ( textFileObj . read ()) text = self . postprocess ( text ) with open ( fileName , \"w\" ) as textFileObj : textFileObj . write ( text ) with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF os . remove ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response ) def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () os . remove ( fileName ) def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : appData , separator , data = data . partition ( LF ) appDataBuffer . extend ( appData + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = MPIState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start () def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear () def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . getParagraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . isComment ( paragraph ): paragraph = self . collapseSpaces ( paragraph ) paragraph = self . capitalise ( paragraph ) paragraph = self . wordwrap ( paragraph ) paragraphs [ i ] = paragraph return \" \\n \" . join ( paragraphs ) def getParagraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . isComment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] def isComment ( self , line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) def collapseSpaces ( self , text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines text = text . replace ( \" \\0 \" , \" \\n \" ) return text def capitalise ( self , text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) def wordwrap ( self , text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False ) Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Attribute isWordWrapping : bool property writable \u00b6 Specifies whether text should be word wrapped during editing or not. Method capitalise ( self , text ) \u00b6 Capitalizes each sentence in a string. Parameters: Name Type Description Default text str The text to perform sentence capitalization on. required Returns: Type Description str The text after each sentence has been capitalized. Source code in mudproto/mpi.py def capitalise ( self , text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) Method collapseSpaces ( self , text ) \u00b6 Collapses all consecutive space and tab characters of a string to a single space character. Parameters: Name Type Description Default text str The text to perform the operation on. required Returns: Type Description str The text with consecutive space and tab characters collapsed. Source code in mudproto/mpi.py def collapseSpaces ( self , text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines text = text . replace ( \" \\0 \" , \" \\n \" ) return text Method edit ( self , data ) \u00b6 Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mudproto/mpi.py def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as tempFileObj : fileName = tempFileObj . name tempFileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : if self . isWordWrapping : with open ( fileName , \"r\" ) as textFileObj : text : str = str ( textFileObj . read ()) text = self . postprocess ( text ) with open ( fileName , \"w\" ) as textFileObj : textFileObj . write ( text ) with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF os . remove ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response ) Method getParagraphs ( self , text ) \u00b6 Extracts paragraphs from a string. Parameters: Name Type Description Default text str The text to analyze. required Returns: Type Description list[str] The extracted paragraphs. Source code in mudproto/mpi.py def getParagraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . isComment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] Method isComment ( self , line ) \u00b6 Determines whether a line is a comment. Parameters: Name Type Description Default line str The line to analyze. required Returns: Type Description bool True if the line is a comment, False otherwise. Source code in mudproto/mpi.py def isComment ( self , line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) Method on_command ( self , command , data ) \u00b6 Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start () Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/mpi.py def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear () Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/mpi.py def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mpi.py def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : appData , separator , data = data . partition ( LF ) appDataBuffer . extend ( appData + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = MPIState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) Method on_unhandledCommand ( self , command , data ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) Method postprocess ( self , text ) \u00b6 Reformats text before it is sent to the game when wordwrapping is enabled. Parameters: Name Type Description Default text str The text to be processed. required Returns: Type Description str The text with formatting applied. Source code in mudproto/mpi.py def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . getParagraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . isComment ( paragraph ): paragraph = self . collapseSpaces ( paragraph ) paragraph = self . capitalise ( paragraph ) paragraph = self . wordwrap ( paragraph ) paragraphs [ i ] = paragraph return \" \\n \" . join ( paragraphs ) Method view ( self , data ) \u00b6 Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mudproto/mpi.py def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () os . remove ( fileName ) Method wordwrap ( self , text ) \u00b6 Wordwraps text using module-specific settings. Parameters: Name Type Description Default text str The text to be wordwrapped. required Returns: Type Description str The text with wordwrapping applied. Source code in mudproto/mpi.py def wordwrap ( self , text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mpi.py def write ( self , data : bytes ) -> None : self . _writer ( data ) Class MPIState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/mpi.py class MPIState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () NEWLINE = auto () INIT = auto () COMMAND = auto () LENGTH = auto () BODY = auto ()","title":"mpi.py"},{"location":"api/mpi/#mudproto.mpi","text":"Mume Remote Editing Protocol.","title":"mpi"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol","text":"Implements support for the Mume remote editing protocol. Attributes: Name Type Description commandMap MPI_COMMAND_MAP_TYPE A mapping of bytes to callables. editor str The program to use for editing received text. pager str The program to use for viewing received read-only text. Source code in mudproto/mpi.py class MPIProtocol ( Protocol ): \"\"\" Implements support for the Mume remote editing protocol. Attributes: commandMap: A mapping of bytes to callables. editor: The program to use for editing received text. pager: The program to use for viewing received read-only text. \"\"\" def __init__ ( self , * args : Any , outputFormat : str , ** kwargs : Any ) -> None : self . outputFormat : str = outputFormat super () . __init__ ( * args , ** kwargs ) self . state : MPIState = MPIState . DATA \"\"\"The state of the state machine.\"\"\" self . _MPIBuffer : bytearray = bytearray () self . _MPIThreads : list [ threading . Thread ] = [] self . commandMap : MPI_COMMAND_MAP_TYPE = { b \"E\" : self . edit , b \"V\" : self . view , } editors : dict [ str , str ] = { \"win32\" : \"notepad\" , } pagers : dict [ str , str ] = { \"win32\" : \"notepad\" , } defaultEditor : str = editors . get ( sys . platform , \"nano\" ) defaultPager : str = pagers . get ( sys . platform , \"less\" ) self . editor : str = os . getenv ( \"VISUAL\" , \"\" ) or os . getenv ( \"EDITOR\" , defaultEditor ) self . pager : str = os . getenv ( \"PAGER\" , defaultPager ) self . _isWordWrapping : bool = False @property def isWordWrapping ( self ) -> bool : \"\"\"Specifies whether text should be word wrapped during editing or not.\"\"\" return self . _isWordWrapping @isWordWrapping . setter def isWordWrapping ( self , value : bool ) -> None : self . _isWordWrapping = value def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as tempFileObj : fileName = tempFileObj . name tempFileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : if self . isWordWrapping : with open ( fileName , \"r\" ) as textFileObj : text : str = str ( textFileObj . read ()) text = self . postprocess ( text ) with open ( fileName , \"w\" ) as textFileObj : textFileObj . write ( text ) with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF os . remove ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response ) def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () os . remove ( fileName ) def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : appData , separator , data = data . partition ( LF ) appDataBuffer . extend ( appData + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = MPIState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start () def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear () def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . getParagraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . isComment ( paragraph ): paragraph = self . collapseSpaces ( paragraph ) paragraph = self . capitalise ( paragraph ) paragraph = self . wordwrap ( paragraph ) paragraphs [ i ] = paragraph return \" \\n \" . join ( paragraphs ) def getParagraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . isComment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ] def isComment ( self , line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" ) def collapseSpaces ( self , text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines text = text . replace ( \" \\0 \" , \" \\n \" ) return text def capitalise ( self , text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" )) def wordwrap ( self , text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False )","title":"MPIProtocol"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.isWordWrapping","text":"Specifies whether text should be word wrapped during editing or not.","title":"isWordWrapping"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.capitalise","text":"Capitalizes each sentence in a string. Parameters: Name Type Description Default text str The text to perform sentence capitalization on. required Returns: Type Description str The text after each sentence has been capitalized. Source code in mudproto/mpi.py def capitalise ( self , text : str ) -> str : \"\"\" Capitalizes each sentence in a string. Args: text: The text to perform sentence capitalization on. Returns: The text after each sentence has been capitalized. \"\"\" return \". \" . join ( sentence . capitalize () for sentence in text . split ( \". \" ))","title":"capitalise()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.collapseSpaces","text":"Collapses all consecutive space and tab characters of a string to a single space character. Parameters: Name Type Description Default text str The text to perform the operation on. required Returns: Type Description str The text with consecutive space and tab characters collapsed. Source code in mudproto/mpi.py def collapseSpaces ( self , text : str ) -> str : \"\"\" Collapses all consecutive space and tab characters of a string to a single space character. Args: text: The text to perform the operation on. Returns: The text with consecutive space and tab characters collapsed. \"\"\" # replace consecutive newlines with a null placeholder text = text . replace ( \" \\n \" , \" \\0 \" ) # collapse all runs of whitespace into a single space text = re . sub ( r \"[ \\t]+\" , \" \" , text . strip ()) # reinsert consecutive newlines text = text . replace ( \" \\0 \" , \" \\n \" ) return text","title":"collapseSpaces()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.edit","text":"Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mudproto/mpi.py def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as tempFileObj : fileName = tempFileObj . name tempFileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : if self . isWordWrapping : with open ( fileName , \"r\" ) as textFileObj : text : str = str ( textFileObj . read ()) text = self . postprocess ( text ) with open ( fileName , \"w\" ) as textFileObj : textFileObj . write ( text ) with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF os . remove ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response )","title":"edit()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.getParagraphs","text":"Extracts paragraphs from a string. Parameters: Name Type Description Default text str The text to analyze. required Returns: Type Description list[str] The extracted paragraphs. Source code in mudproto/mpi.py def getParagraphs ( self , text : str ) -> list [ str ]: \"\"\" Extracts paragraphs from a string. Args: text: The text to analyze. Returns: The extracted paragraphs. \"\"\" lines : list [ str ] = text . splitlines () lineno : int = 0 while lineno < len ( lines ): if self . isComment ( lines [ lineno ]): if lineno > 0 : lines [ lineno ] = \" \\0 \" + lines [ lineno ] if lineno + 1 < len ( lines ): lines [ lineno ] += \" \\0 \" lineno += 1 text = \" \\n \" . join ( lines ) text = re . sub ( r \"\\0\\n\\0?\" , \" \\0 \" , text ) lines = [ line . rstrip () for line in text . split ( \" \\0 \" )] return [ line for line in lines if line ]","title":"getParagraphs()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.isComment","text":"Determines whether a line is a comment. Parameters: Name Type Description Default line str The line to analyze. required Returns: Type Description bool True if the line is a comment, False otherwise. Source code in mudproto/mpi.py def isComment ( self , line : str ) -> bool : \"\"\" Determines whether a line is a comment. Args: line: The line to analyze. Returns: True if the line is a comment, False otherwise. \"\"\" return line . lstrip () . startswith ( \"#\" )","title":"isComment()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_command","text":"Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start ()","title":"on_command()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/mpi.py def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear ()","title":"on_connectionLost()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/mpi.py def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF )","title":"on_connectionMade()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/mpi.py def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is MPIState . DATA : appData , separator , data = data . partition ( LF ) appDataBuffer . extend ( appData + separator ) if separator : self . state = MPIState . NEWLINE elif self . state is MPIState . NEWLINE : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = MPIState . INIT else : self . state = MPIState . DATA elif self . state is MPIState . INIT : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = MPIState . COMMAND elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = MPIState . DATA elif self . state is MPIState . COMMAND : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = MPIState . LENGTH elif self . state is MPIState . LENGTH : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = MPIState . DATA elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = MPIState . BODY elif self . state is MPIState . BODY : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = MPIState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mudproto/mpi.py def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data )","title":"on_unhandledCommand()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.postprocess","text":"Reformats text before it is sent to the game when wordwrapping is enabled. Parameters: Name Type Description Default text str The text to be processed. required Returns: Type Description str The text with formatting applied. Source code in mudproto/mpi.py def postprocess ( self , text : str ) -> str : \"\"\" Reformats text before it is sent to the game when wordwrapping is enabled. Args: text: The text to be processed. Returns: The text with formatting applied. \"\"\" paragraphs : list [ str ] = self . getParagraphs ( text ) for i , paragraph in enumerate ( paragraphs ): if not self . isComment ( paragraph ): paragraph = self . collapseSpaces ( paragraph ) paragraph = self . capitalise ( paragraph ) paragraph = self . wordwrap ( paragraph ) paragraphs [ i ] = paragraph return \" \\n \" . join ( paragraphs )","title":"postprocess()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.view","text":"Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mudproto/mpi.py def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () os . remove ( fileName )","title":"view()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.wordwrap","text":"Wordwraps text using module-specific settings. Parameters: Name Type Description Default text str The text to be wordwrapped. required Returns: Type Description str The text with wordwrapping applied. Source code in mudproto/mpi.py def wordwrap ( self , text : str ) -> str : \"\"\" Wordwraps text using module-specific settings. Args: text: The text to be wordwrapped. Returns: The text with wordwrapping applied. \"\"\" return textwrap . fill ( text , width = 79 , drop_whitespace = True , break_long_words = False , break_on_hyphens = False )","title":"wordwrap()"},{"location":"api/mpi/#mudproto.mpi.MPIProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/mpi.py def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/mpi/#mudproto.mpi.MPIState","text":"Valid states for the state machine. Source code in mudproto/mpi.py class MPIState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () NEWLINE = auto () INIT = auto () COMMAND = auto () LENGTH = auto () BODY = auto ()","title":"MPIState"},{"location":"api/telnet/","text":"Module mudproto.telnet \u00b6 Telnet protocol. Class BaseTelnetProtocol( BaseProtocol , Protocol ) \u00b6 Source code in mudproto/telnet.py class BaseTelnetProtocol ( BaseProtocol , TypeProtocol ): commandMap : TELNET_COMMAND_MAP_TYPE \"\"\"A mapping of bytes to callables.\"\"\" subnegotiationMap : TELNET_SUBNEGOTIATION_MAP_TYPE \"\"\"A mapping of bytes to callables.\"\"\" @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method do ( self , option ) \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" Method dont ( self , option ) \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" Method getOptionState ( self , option ) \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_disableRemote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" Method on_enableRemote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" Method on_optionEnabled ( self , option ) \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\" Method on_subnegotiation ( self , option , data ) \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method requestNegotiation ( self , option , data ) \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" Method will ( self , option ) \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" Method wont ( self , option ) \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" Class TelnetError( Exception ) \u00b6 Implements the base class for Telnet exceptions. Source code in mudproto/telnet.py class TelnetError ( Exception ): \"\"\"Implements the base class for Telnet exceptions.\"\"\" Class TelnetProtocol( Protocol , BaseTelnetProtocol ) \u00b6 Implements the Telnet protocol. Source code in mudproto/telnet.py class TelnetProtocol ( Protocol , BaseTelnetProtocol ): \"\"\" Implements the Telnet protocol. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte # (the first byte after IAC) is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . commandMap : TELNET_COMMAND_MAP_TYPE = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte (the # first byte after SB) is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiationMap : TELNET_SUBNEGOTIATION_MAP_TYPE = {} def _do ( self , option : bytes ) -> None : \"\"\" Sends IAC DO option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DO { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DO + option ) def _dont ( self , option : bytes ) -> None : \"\"\" Sends IAC DONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DONT + option ) def _will ( self , option : bytes ) -> None : \"\"\" Sends IAC WILL option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WILL { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WILL + option ) def _wont ( self , option : bytes ) -> None : \"\"\" Sends IAC WONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WONT + option ) def will ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) def wont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) def do ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) def dont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) def getOptionState ( self , option : bytes ) -> _OptionState : if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] def requestNegotiation ( self , option : bytes , data : bytes ) -> None : self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) def on_connectionMade ( self ) -> None : pass def on_connectionLost ( self ) -> None : pass def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : appData , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif appData . endswith ( CR ): self . state = TelnetState . NEWLINE appData = appData [: - 1 ] appDataBuffer . extend ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. appDataBuffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : appDataBuffer . extend ( byte ) elif byte == NULL : appDataBuffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . extend ( CR ) self . state = TelnetState . COMMAND else : appDataBuffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option ) def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) self . on_optionEnabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_optionEnabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) self . on_optionEnabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) self . on_optionEnabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default. def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) def on_optionEnabled ( self , option : bytes ) -> None : pass # Do nothing by default. Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Method do ( self , option ) \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py def do ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py def dont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method getOptionState ( self , option ) \u00b6 Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py def getOptionState ( self , option : bytes ) -> _OptionState : if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option ) Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : appData , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif appData . endswith ( CR ): self . state = TelnetState . NEWLINE appData = appData [: - 1 ] appDataBuffer . extend ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. appDataBuffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : appDataBuffer . extend ( byte ) elif byte == NULL : appDataBuffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . extend ( CR ) self . state = TelnetState . COMMAND else : appDataBuffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disableRemote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) Method on_do ( self , option ) \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) self . on_optionEnabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) self . on_optionEnabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_enableRemote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_optionEnabled ( self , option ) \u00b6 Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py def on_optionEnabled ( self , option : bytes ) -> None : pass # Do nothing by default. Method on_subnegotiation ( self , option , data ) \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass Method on_will ( self , option ) \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) self . on_optionEnabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_optionEnabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) Method requestNegotiation ( self , option , data ) \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def requestNegotiation ( self , option : bytes , data : bytes ) -> None : self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) Method will ( self , option ) \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py def will ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py def wont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : self . _writer ( data ) Class TelnetState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/telnet.py class TelnetState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () COMMAND = auto () NEWLINE = auto () NEGOTIATION = auto () SUBNEGOTIATION = auto () SUBNEGOTIATION_ESCAPED = auto ()","title":"telnet.py"},{"location":"api/telnet/#mudproto.telnet","text":"Telnet protocol.","title":"telnet"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol","text":"Source code in mudproto/telnet.py class BaseTelnetProtocol ( BaseProtocol , TypeProtocol ): commandMap : TELNET_COMMAND_MAP_TYPE \"\"\"A mapping of bytes to callables.\"\"\" subnegotiationMap : TELNET_SUBNEGOTIATION_MAP_TYPE \"\"\"A mapping of bytes to callables.\"\"\" @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\" @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"BaseTelnetProtocol"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py @abstractmethod def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\"","title":"do()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py @abstractmethod def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\"","title":"dont()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.getOptionState","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py @abstractmethod def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Args: option: The option to get state. Returns: An object containing the option state. \"\"\"","title":"getOptionState()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_command()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\"","title":"on_dataReceived()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableLocal()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableRemote()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\"","title":"on_enableLocal()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\"","title":"on_enableRemote()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_optionEnabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py @abstractmethod def on_optionEnabled ( self , option : bytes ) -> None : \"\"\" Called after an option has been fully enabled. Args: option: The option that has been enabled. \"\"\"","title":"on_optionEnabled()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandledCommand()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandledSubnegotiation()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py @abstractmethod def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"requestNegotiation()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py @abstractmethod def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\"","title":"will()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py @abstractmethod def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\"","title":"wont()"},{"location":"api/telnet/#mudproto.telnet.BaseTelnetProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"write()"},{"location":"api/telnet/#mudproto.telnet.TelnetError","text":"Implements the base class for Telnet exceptions. Source code in mudproto/telnet.py class TelnetError ( Exception ): \"\"\"Implements the base class for Telnet exceptions.\"\"\"","title":"TelnetError"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol","text":"Implements the Telnet protocol. Source code in mudproto/telnet.py class TelnetProtocol ( Protocol , BaseTelnetProtocol ): \"\"\" Implements the Telnet protocol. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . state : TelnetState = TelnetState . DATA \"\"\"The state of the state machine.\"\"\" self . _options : dict [ bytes , _OptionState ] = {} \"\"\"A mapping of option bytes to their current state.\"\"\" # When a Telnet command is received, the command byte # (the first byte after IAC) is looked up in the commandMap dictionary. # If a callable is found, it is invoked with the argument of the command, # or None if the command takes no argument. Values should be added to # this dictionary if commands wish to be handled. By default, # only WILL, WONT, DO, and DONT are handled. These should not # be overridden, as this class handles them correctly and # provides an API for interacting with them. self . commandMap : TELNET_COMMAND_MAP_TYPE = { WILL : self . on_will , WONT : self . on_wont , DO : self . on_do , DONT : self . on_dont , } # When a subnegotiation command is received, the option byte (the # first byte after SB) is looked up in the subnegotiationMap dictionary. If # a callable is found, it is invoked with the argument of the # subnegotiation. Values should be added to this dictionary if # subnegotiations are to be handled. By default, no values are # handled. self . subnegotiationMap : TELNET_SUBNEGOTIATION_MAP_TYPE = {} def _do ( self , option : bytes ) -> None : \"\"\" Sends IAC DO option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DO { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DO + option ) def _dont ( self , option : bytes ) -> None : \"\"\" Sends IAC DONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC DONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + DONT + option ) def _will ( self , option : bytes ) -> None : \"\"\" Sends IAC WILL option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WILL { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WILL + option ) def _wont ( self , option : bytes ) -> None : \"\"\" Sends IAC WONT option to the peer. Args: option: The option to send. \"\"\" logger . debug ( f \"Send to peer: IAC WONT { DESCRIPTIONS . get ( option , repr ( option )) } \" ) self . write ( IAC + WONT + option ) def will ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) def wont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) def do ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) def dont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) def getOptionState ( self , option : bytes ) -> _OptionState : if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] def requestNegotiation ( self , option : bytes , data : bytes ) -> None : self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) def on_connectionMade ( self ) -> None : pass def on_connectionLost ( self ) -> None : pass def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : appData , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif appData . endswith ( CR ): self . state = TelnetState . NEWLINE appData = appData [: - 1 ] appDataBuffer . extend ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. appDataBuffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : appDataBuffer . extend ( byte ) elif byte == NULL : appDataBuffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . extend ( CR ) self . state = TelnetState . COMMAND else : appDataBuffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option ) def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) self . on_optionEnabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_optionEnabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) self . on_optionEnabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) self . on_optionEnabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default. def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" ) def on_optionEnabled ( self , option : bytes ) -> None : pass # Do nothing by default.","title":"TelnetProtocol"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mudproto/telnet.py def do ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mudproto/telnet.py def dont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.getOptionState","text":"Gets the state of a Telnet option. Parameters: Name Type Description Default option bytes The option to get state. required Returns: Type Description _OptionState An object containing the option state. Source code in mudproto/telnet.py def getOptionState ( self , option : bytes ) -> _OptionState : if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"getOptionState()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option )","title":"on_command()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/telnet.py def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/telnet.py def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/telnet.py def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer : bytearray = bytearray () while data : if self . state is TelnetState . DATA : appData , separator , data = data . partition ( IAC ) if separator : self . state = TelnetState . COMMAND elif appData . endswith ( CR ): self . state = TelnetState . NEWLINE appData = appData [: - 1 ] appDataBuffer . extend ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state is TelnetState . COMMAND : if byte == IAC : # Escaped IAC. appDataBuffer . extend ( byte ) self . state = TelnetState . DATA elif byte == SE : self . state = TelnetState . DATA logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = TelnetState . SUBNEGOTIATION self . _commands : bytearray = bytearray () elif byte in COMMAND_BYTES : self . state = TelnetState . DATA if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ byte ] } \" ) self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = TelnetState . NEGOTIATION self . _command = byte else : self . state = TelnetState . DATA logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state is TelnetState . NEGOTIATION : self . state = TelnetState . DATA command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () logger . debug ( f \"Received from peer: IAC { DESCRIPTIONS [ command ] } { DESCRIPTIONS . get ( byte , repr ( byte )) } \" ) self . on_command ( command , byte ) elif self . state is TelnetState . NEWLINE : self . state = TelnetState . DATA if byte == LF : appDataBuffer . extend ( byte ) elif byte == NULL : appDataBuffer . extend ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . extend ( CR ) self . state = TelnetState . COMMAND else : appDataBuffer . extend ( CR + byte ) elif self . state is TelnetState . SUBNEGOTIATION : if byte == IAC : self . state = TelnetState . SUBNEGOTIATION_ESCAPED else : self . _commands . extend ( byte ) elif self . state is TelnetState . SUBNEGOTIATION_ESCAPED : if byte == SE : self . state = TelnetState . DATA commands = bytes ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer )) appDataBuffer . clear () option , commands = commands [: 1 ], commands [ 1 :] logger . debug ( f \"Received from peer: IAC SB { DESCRIPTIONS . get ( option , repr ( option )) } { commands !r} IAC SE\" ) self . on_subnegotiation ( option , commands ) else : self . state = TelnetState . SUBNEGOTIATION self . _commands . extend ( byte ) if appDataBuffer : super () . on_dataReceived ( bytes ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableLocal()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mudproto/telnet.py def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable remote Telnet option { option !r} \" )","title":"on_disableRemote()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) self . on_optionEnabled ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) self . on_optionEnabled ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { DESCRIPTIONS . get ( option , repr ( option )) } .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option )","title":"on_dont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mudproto/telnet.py def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableLocal()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mudproto/telnet.py def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableRemote()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_optionEnabled","text":"Called after an option has been fully enabled. Parameters: Name Type Description Default option bytes The option that has been enabled. required Source code in mudproto/telnet.py def on_optionEnabled ( self , option : bytes ) -> None : pass # Do nothing by default.","title":"on_optionEnabled()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mudproto/telnet.py def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass","title":"on_unhandledCommand()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass","title":"on_unhandledSubnegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) self . on_optionEnabled ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) self . on_optionEnabled ( option ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mudproto/telnet.py def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { DESCRIPTIONS . get ( option , repr ( option )) } in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option )","title":"on_wont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mudproto/telnet.py def requestNegotiation ( self , option : bytes , data : bytes ) -> None : self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE )","title":"requestNegotiation()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mudproto/telnet.py def will ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mudproto/telnet.py def wont ( self , option : bytes ) -> None : state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/telnet/#mudproto.telnet.TelnetProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/telnet.py def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/telnet/#mudproto.telnet.TelnetState","text":"Valid states for the state machine. Source code in mudproto/telnet.py class TelnetState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () COMMAND = auto () NEWLINE = auto () NEGOTIATION = auto () SUBNEGOTIATION = auto () SUBNEGOTIATION_ESCAPED = auto ()","title":"TelnetState"},{"location":"api/utils/","text":"Module mudproto.utils \u00b6 Function escapeIAC ( data ) \u00b6 Escapes IAC bytes of a bytes-like object. Parameters: Name Type Description Default data bytes The data to be escaped. required Returns: Type Description bytes The data with IAC bytes escaped. Source code in mudproto/utils.py def escapeIAC ( data : bytes ) -> bytes : \"\"\" Escapes IAC bytes of a bytes-like object. Args: data: The data to be escaped. Returns: The data with IAC bytes escaped. \"\"\" return data . replace ( IAC , IAC_IAC ) Function escapeXMLString ( text ) \u00b6 Escapes XML entities in a string. Parameters: Name Type Description Default text str The string to escape. required Returns: Type Description str A copy of the string with XML entities escaped. Source code in mudproto/utils.py def escapeXMLString ( text : str ) -> str : \"\"\" Escapes XML entities in a string. Args: text: The string to escape. Returns: A copy of the string with XML entities escaped. \"\"\" return multiReplace ( text , ESCAPE_XML_STR_ENTITIES ) Function iterBytes ( data ) \u00b6 A generator which yields each byte of a bytes-like object. Parameters: Name Type Description Default data bytes The data to process. required Yields: Type Description Generator[bytes, None, None] Each byte of data as a bytes object. Source code in mudproto/utils.py def iterBytes ( data : bytes ) -> Generator [ bytes , None , None ]: \"\"\" A generator which yields each byte of a bytes-like object. Args: data: The data to process. Yields: Each byte of data as a bytes object. \"\"\" for i in range ( len ( data )): yield data [ i : i + 1 ] Function multiReplace ( data , replacements ) \u00b6 Performs multiple replacement operations on a string or bytes-like object. Parameters: Name Type Description Default data AnyStr The text to perform the replacements on. required replacements Union[Sequence[Sequence[bytes]], Sequence[Sequence[str]]] A sequence of tuples, each containing the text to match and the replacement. required Returns: Type Description AnyStr The text with all the replacements applied. Source code in mudproto/utils.py def multiReplace ( data : AnyStr , replacements : Union [ Sequence [ Sequence [ bytes ]], Sequence [ Sequence [ str ]]] ) -> AnyStr : \"\"\" Performs multiple replacement operations on a string or bytes-like object. Args: data: The text to perform the replacements on. replacements: A sequence of tuples, each containing the text to match and the replacement. Returns: The text with all the replacements applied. \"\"\" for item in replacements : data = data . replace ( * item ) return data Function unescapeXMLBytes ( data ) \u00b6 Unescapes XML entities in a bytes-like object. Parameters: Name Type Description Default data bytes The data to unescape. required Returns: Type Description bytes A copy of the data with XML entities unescaped. Source code in mudproto/utils.py def unescapeXMLBytes ( data : bytes ) -> bytes : \"\"\" Unescapes XML entities in a bytes-like object. Args: data: The data to unescape. Returns: A copy of the data with XML entities unescaped. \"\"\" def referenceToBytes ( match : re . Match [ bytes ]) -> bytes : isHex : bytes = match . group ( \"hex\" ) value : bytes = match . group ( \"value\" ) return bytes (( int ( value , 16 if isHex else 10 ),)) return multiReplace ( UNESCAPE_XML_NUMERIC_BYTES_REGEX . sub ( referenceToBytes , data ), UNESCAPE_XML_BYTES_ENTITIES )","title":"utils.py"},{"location":"api/utils/#mudproto.utils","text":"","title":"utils"},{"location":"api/utils/#mudproto.utils.escapeIAC","text":"Escapes IAC bytes of a bytes-like object. Parameters: Name Type Description Default data bytes The data to be escaped. required Returns: Type Description bytes The data with IAC bytes escaped. Source code in mudproto/utils.py def escapeIAC ( data : bytes ) -> bytes : \"\"\" Escapes IAC bytes of a bytes-like object. Args: data: The data to be escaped. Returns: The data with IAC bytes escaped. \"\"\" return data . replace ( IAC , IAC_IAC )","title":"escapeIAC()"},{"location":"api/utils/#mudproto.utils.escapeXMLString","text":"Escapes XML entities in a string. Parameters: Name Type Description Default text str The string to escape. required Returns: Type Description str A copy of the string with XML entities escaped. Source code in mudproto/utils.py def escapeXMLString ( text : str ) -> str : \"\"\" Escapes XML entities in a string. Args: text: The string to escape. Returns: A copy of the string with XML entities escaped. \"\"\" return multiReplace ( text , ESCAPE_XML_STR_ENTITIES )","title":"escapeXMLString()"},{"location":"api/utils/#mudproto.utils.iterBytes","text":"A generator which yields each byte of a bytes-like object. Parameters: Name Type Description Default data bytes The data to process. required Yields: Type Description Generator[bytes, None, None] Each byte of data as a bytes object. Source code in mudproto/utils.py def iterBytes ( data : bytes ) -> Generator [ bytes , None , None ]: \"\"\" A generator which yields each byte of a bytes-like object. Args: data: The data to process. Yields: Each byte of data as a bytes object. \"\"\" for i in range ( len ( data )): yield data [ i : i + 1 ]","title":"iterBytes()"},{"location":"api/utils/#mudproto.utils.multiReplace","text":"Performs multiple replacement operations on a string or bytes-like object. Parameters: Name Type Description Default data AnyStr The text to perform the replacements on. required replacements Union[Sequence[Sequence[bytes]], Sequence[Sequence[str]]] A sequence of tuples, each containing the text to match and the replacement. required Returns: Type Description AnyStr The text with all the replacements applied. Source code in mudproto/utils.py def multiReplace ( data : AnyStr , replacements : Union [ Sequence [ Sequence [ bytes ]], Sequence [ Sequence [ str ]]] ) -> AnyStr : \"\"\" Performs multiple replacement operations on a string or bytes-like object. Args: data: The text to perform the replacements on. replacements: A sequence of tuples, each containing the text to match and the replacement. Returns: The text with all the replacements applied. \"\"\" for item in replacements : data = data . replace ( * item ) return data","title":"multiReplace()"},{"location":"api/utils/#mudproto.utils.unescapeXMLBytes","text":"Unescapes XML entities in a bytes-like object. Parameters: Name Type Description Default data bytes The data to unescape. required Returns: Type Description bytes A copy of the data with XML entities unescaped. Source code in mudproto/utils.py def unescapeXMLBytes ( data : bytes ) -> bytes : \"\"\" Unescapes XML entities in a bytes-like object. Args: data: The data to unescape. Returns: A copy of the data with XML entities unescaped. \"\"\" def referenceToBytes ( match : re . Match [ bytes ]) -> bytes : isHex : bytes = match . group ( \"hex\" ) value : bytes = match . group ( \"value\" ) return bytes (( int ( value , 16 if isHex else 10 ),)) return multiReplace ( UNESCAPE_XML_NUMERIC_BYTES_REGEX . sub ( referenceToBytes , data ), UNESCAPE_XML_BYTES_ENTITIES )","title":"unescapeXMLBytes()"},{"location":"api/xml/","text":"Module mudproto.xml \u00b6 Mume XML Protocol. Class XMLProtocol( Protocol ) \u00b6 Implements the Mume XML protocol. Source code in mudproto/xml.py class XMLProtocol ( Protocol ): \"\"\" Implements the Mume XML protocol. \"\"\" modes : ClassVar [ dict [ bytes , Union [ bytes , None ]]] = { b \"room\" : b \"room\" , b \"/room\" : None , b \"name\" : b \"name\" , b \"/name\" : b \"room\" , b \"description\" : b \"description\" , b \"/description\" : b \"room\" , b \"terrain\" : None , b \"/terrain\" : b \"room\" , b \"magic\" : b \"magic\" , b \"/magic\" : None , b \"exits\" : b \"exits\" , b \"/exits\" : None , b \"prompt\" : b \"prompt\" , b \"/prompt\" : None , } \"\"\"A mapping of XML mode to new XML mode values.\"\"\" tintinReplacements : ClassVar [ dict [ bytes , bytes ]] = { b \"prompt\" : b \"PROMPT:\" , b \"/prompt\" : b \":PROMPT\" , b \"name\" : b \"NAME:\" , b \"/name\" : b \":NAME\" , b \"tell\" : b \"TELL:\" , b \"/tell\" : b \":TELL\" , b \"narrate\" : b \"NARRATE:\" , b \"/narrate\" : b \":NARRATE\" , b \"pray\" : b \"PRAY:\" , b \"/pray\" : b \":PRAY\" , b \"say\" : b \"SAY:\" , b \"/say\" : b \":SAY\" , b \"emote\" : b \"EMOTE:\" , b \"/emote\" : b \":EMOTE\" , } \"\"\"A mapping of tag to replacement values for Tintin.\"\"\" ignoredSubTags : ClassVar [ frozenset [ bytes ]] = frozenset ( { b \"character\" , b \"enemy\" , b \"object\" , b \"player\" , b \"status\" } ) \"\"\"Tags that can appear inside other tags and should be ignored.\"\"\" def __init__ ( self , * args : Any , outputFormat : str , ** kwargs : Any , ) -> None : self . outputFormat : str = outputFormat super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tagBuffer : bytearray = bytearray () # Used for start and end tag names. self . _textBuffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamicBuffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _lineBuffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _inRoom : bool = False self . _mode : Union [ bytes , None ] = None def _handleXMLText ( self , data : bytes , appDataBuffer : bytearray ) -> bytes : \"\"\" Handles XML data that is not part of a tag. Args: data: The received data. appDataBuffer: The application level data buffer. Returns: The remaining data. \"\"\" appData , separator , data = data . partition ( LT ) if not ( self . _gratuitous and self . outputFormat != \"raw\" ): # Gratuitous text should be omitted unless format is 'raw'. appDataBuffer . extend ( appData ) if self . _mode is None : self . _lineBuffer . extend ( appData ) lines = self . _lineBuffer . splitlines ( True ) self . _lineBuffer . clear () if lines and lines [ - 1 ][ - 1 :] not in ( CR , LF ): # Final line is incomplete. self . _lineBuffer . extend ( lines . pop ()) lines = [ line . rstrip ( CR_LF ) for line in lines if line . strip ()] for line in lines : self . on_xmlEvent ( \"line\" , unescapeXMLBytes ( line )) else : self . _textBuffer . extend ( appData ) if separator : self . state = XMLState . TAG return data def _handleXMLTag ( self , data : bytes , appDataBuffer : bytearray ) -> bytes : \"\"\" Handles XML data that is part of a tag (I.E. enclosed in '<>'). Args: data: The received data. appDataBuffer: The application level data buffer. Returns: The remaining data. \"\"\" appData , separator , data = data . partition ( GT ) self . _tagBuffer . extend ( appData ) if not separator : # End of tag not reached yet. return data tag : bytes = bytes ( self . _tagBuffer ) . strip () self . _tagBuffer . clear () baseTag : bytes = tag . lstrip ( b \"/\" ) text : bytes = bytes ( self . _textBuffer ) if baseTag not in self . ignoredSubTags and not ( baseTag != b \"exits\" and baseTag . startswith ( b \"exit\" )): self . _textBuffer . clear () if self . outputFormat == \"raw\" : appDataBuffer . extend ( LT + tag + GT ) elif self . outputFormat == \"tintin\" and not self . _gratuitous : appDataBuffer . extend ( self . tintinReplacements . get ( tag , b \"\" )) if self . _mode is None and tag . startswith ( b \"movement\" ): self . on_xmlEvent ( \"movement\" , unescapeXMLBytes ( tag [ 13 : - 1 ])) elif baseTag == b \"gratuitous\" : self . _gratuitous = not tag . startswith ( b \"/\" ) elif tag . startswith ( b \"room\" ): self . _inRoom = True self . _mode = self . modes [ b \"room\" ] self . on_xmlEvent ( \"room\" , unescapeXMLBytes ( tag [ 5 :])) elif tag == b \"/room\" : self . _inRoom = False self . _mode = self . modes [ tag ] self . _dynamicBuffer . extend ( text ) self . on_xmlEvent ( \"dynamic\" , unescapeXMLBytes ( bytes ( self . _dynamicBuffer ) . lstrip ( b \" \\r\\n \" ))) self . _dynamicBuffer . clear () elif tag in self . modes : if tag . startswith ( b \"/\" ): # Closing tag. self . _mode = b \"room\" if self . _inRoom else self . modes [ tag ] self . on_xmlEvent ( tag [ 1 :] . decode ( \"us-ascii\" ), unescapeXMLBytes ( text )) else : # Opening tag. self . _mode = self . modes [ tag ] if self . _inRoom : self . _dynamicBuffer . extend ( text ) self . state = XMLState . DATA return data def on_dataReceived ( self , data : bytes ) -> None : appDataBuffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handleXMLText ( data , appDataBuffer ) elif self . state is XMLState . TAG : data = self . _handleXMLTag ( data , appDataBuffer ) if appDataBuffer : if self . outputFormat == \"raw\" : super () . on_dataReceived ( bytes ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXMLBytes ( bytes ( appDataBuffer ))) def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) def on_connectionLost ( self ) -> None : pass def on_xmlEvent ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\" Attribute ignoredSubTags : ClassVar [ frozenset [ bytes ]] \u00b6 Tags that can appear inside other tags and should be ignored. Attribute isClient : bool inherited property readonly \u00b6 True if acting as a client, False otherwise. Attribute isServer : bool inherited property readonly \u00b6 True if acting as a server, False otherwise. Attribute modes : ClassVar [ dict [ bytes , Optional [ bytes ]]] \u00b6 A mapping of XML mode to new XML mode values. Attribute tintinReplacements : ClassVar [ dict [ bytes , bytes ]] \u00b6 A mapping of tag to replacement values for Tintin. Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mudproto/xml.py def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mudproto/xml.py def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/xml.py def on_dataReceived ( self , data : bytes ) -> None : appDataBuffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handleXMLText ( data , appDataBuffer ) elif self . state is XMLState . TAG : data = self . _handleXMLTag ( data , appDataBuffer ) if appDataBuffer : if self . outputFormat == \"raw\" : super () . on_dataReceived ( bytes ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXMLBytes ( bytes ( appDataBuffer ))) Method on_xmlEvent ( self , name , data ) \u00b6 Called when an XML event was received. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mudproto/xml.py def on_xmlEvent ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/xml.py def write ( self , data : bytes ) -> None : self . _writer ( data ) Class XMLState( Enum ) \u00b6 Valid states for the state machine. Source code in mudproto/xml.py class XMLState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () TAG = auto ()","title":"xml.py"},{"location":"api/xml/#mudproto.xml","text":"Mume XML Protocol.","title":"xml"},{"location":"api/xml/#mudproto.xml.XMLProtocol","text":"Implements the Mume XML protocol. Source code in mudproto/xml.py class XMLProtocol ( Protocol ): \"\"\" Implements the Mume XML protocol. \"\"\" modes : ClassVar [ dict [ bytes , Union [ bytes , None ]]] = { b \"room\" : b \"room\" , b \"/room\" : None , b \"name\" : b \"name\" , b \"/name\" : b \"room\" , b \"description\" : b \"description\" , b \"/description\" : b \"room\" , b \"terrain\" : None , b \"/terrain\" : b \"room\" , b \"magic\" : b \"magic\" , b \"/magic\" : None , b \"exits\" : b \"exits\" , b \"/exits\" : None , b \"prompt\" : b \"prompt\" , b \"/prompt\" : None , } \"\"\"A mapping of XML mode to new XML mode values.\"\"\" tintinReplacements : ClassVar [ dict [ bytes , bytes ]] = { b \"prompt\" : b \"PROMPT:\" , b \"/prompt\" : b \":PROMPT\" , b \"name\" : b \"NAME:\" , b \"/name\" : b \":NAME\" , b \"tell\" : b \"TELL:\" , b \"/tell\" : b \":TELL\" , b \"narrate\" : b \"NARRATE:\" , b \"/narrate\" : b \":NARRATE\" , b \"pray\" : b \"PRAY:\" , b \"/pray\" : b \":PRAY\" , b \"say\" : b \"SAY:\" , b \"/say\" : b \":SAY\" , b \"emote\" : b \"EMOTE:\" , b \"/emote\" : b \":EMOTE\" , } \"\"\"A mapping of tag to replacement values for Tintin.\"\"\" ignoredSubTags : ClassVar [ frozenset [ bytes ]] = frozenset ( { b \"character\" , b \"enemy\" , b \"object\" , b \"player\" , b \"status\" } ) \"\"\"Tags that can appear inside other tags and should be ignored.\"\"\" def __init__ ( self , * args : Any , outputFormat : str , ** kwargs : Any , ) -> None : self . outputFormat : str = outputFormat super () . __init__ ( * args , ** kwargs ) self . state : XMLState = XMLState . DATA \"\"\"The state of the state machine.\"\"\" self . _tagBuffer : bytearray = bytearray () # Used for start and end tag names. self . _textBuffer : bytearray = bytearray () # Used for the text between start and end tags. self . _dynamicBuffer : bytearray = bytearray () # Used for dynamic room descriptions. self . _lineBuffer : bytearray = bytearray () # Used for non-XML lines. self . _gratuitous : bool = False self . _inRoom : bool = False self . _mode : Union [ bytes , None ] = None def _handleXMLText ( self , data : bytes , appDataBuffer : bytearray ) -> bytes : \"\"\" Handles XML data that is not part of a tag. Args: data: The received data. appDataBuffer: The application level data buffer. Returns: The remaining data. \"\"\" appData , separator , data = data . partition ( LT ) if not ( self . _gratuitous and self . outputFormat != \"raw\" ): # Gratuitous text should be omitted unless format is 'raw'. appDataBuffer . extend ( appData ) if self . _mode is None : self . _lineBuffer . extend ( appData ) lines = self . _lineBuffer . splitlines ( True ) self . _lineBuffer . clear () if lines and lines [ - 1 ][ - 1 :] not in ( CR , LF ): # Final line is incomplete. self . _lineBuffer . extend ( lines . pop ()) lines = [ line . rstrip ( CR_LF ) for line in lines if line . strip ()] for line in lines : self . on_xmlEvent ( \"line\" , unescapeXMLBytes ( line )) else : self . _textBuffer . extend ( appData ) if separator : self . state = XMLState . TAG return data def _handleXMLTag ( self , data : bytes , appDataBuffer : bytearray ) -> bytes : \"\"\" Handles XML data that is part of a tag (I.E. enclosed in '<>'). Args: data: The received data. appDataBuffer: The application level data buffer. Returns: The remaining data. \"\"\" appData , separator , data = data . partition ( GT ) self . _tagBuffer . extend ( appData ) if not separator : # End of tag not reached yet. return data tag : bytes = bytes ( self . _tagBuffer ) . strip () self . _tagBuffer . clear () baseTag : bytes = tag . lstrip ( b \"/\" ) text : bytes = bytes ( self . _textBuffer ) if baseTag not in self . ignoredSubTags and not ( baseTag != b \"exits\" and baseTag . startswith ( b \"exit\" )): self . _textBuffer . clear () if self . outputFormat == \"raw\" : appDataBuffer . extend ( LT + tag + GT ) elif self . outputFormat == \"tintin\" and not self . _gratuitous : appDataBuffer . extend ( self . tintinReplacements . get ( tag , b \"\" )) if self . _mode is None and tag . startswith ( b \"movement\" ): self . on_xmlEvent ( \"movement\" , unescapeXMLBytes ( tag [ 13 : - 1 ])) elif baseTag == b \"gratuitous\" : self . _gratuitous = not tag . startswith ( b \"/\" ) elif tag . startswith ( b \"room\" ): self . _inRoom = True self . _mode = self . modes [ b \"room\" ] self . on_xmlEvent ( \"room\" , unescapeXMLBytes ( tag [ 5 :])) elif tag == b \"/room\" : self . _inRoom = False self . _mode = self . modes [ tag ] self . _dynamicBuffer . extend ( text ) self . on_xmlEvent ( \"dynamic\" , unescapeXMLBytes ( bytes ( self . _dynamicBuffer ) . lstrip ( b \" \\r\\n \" ))) self . _dynamicBuffer . clear () elif tag in self . modes : if tag . startswith ( b \"/\" ): # Closing tag. self . _mode = b \"room\" if self . _inRoom else self . modes [ tag ] self . on_xmlEvent ( tag [ 1 :] . decode ( \"us-ascii\" ), unescapeXMLBytes ( text )) else : # Opening tag. self . _mode = self . modes [ tag ] if self . _inRoom : self . _dynamicBuffer . extend ( text ) self . state = XMLState . DATA return data def on_dataReceived ( self , data : bytes ) -> None : appDataBuffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handleXMLText ( data , appDataBuffer ) elif self . state is XMLState . TAG : data = self . _handleXMLTag ( data , appDataBuffer ) if appDataBuffer : if self . outputFormat == \"raw\" : super () . on_dataReceived ( bytes ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXMLBytes ( bytes ( appDataBuffer ))) def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) def on_connectionLost ( self ) -> None : pass def on_xmlEvent ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\"","title":"XMLProtocol"},{"location":"api/xml/#mudproto.xml.XMLProtocol.ignoredSubTags","text":"Tags that can appear inside other tags and should be ignored.","title":"ignoredSubTags"},{"location":"api/xml/#mudproto.xml.XMLProtocol.isClient","text":"True if acting as a client, False otherwise.","title":"isClient"},{"location":"api/xml/#mudproto.xml.XMLProtocol.isServer","text":"True if acting as a server, False otherwise.","title":"isServer"},{"location":"api/xml/#mudproto.xml.XMLProtocol.modes","text":"A mapping of XML mode to new XML mode values.","title":"modes"},{"location":"api/xml/#mudproto.xml.XMLProtocol.tintinReplacements","text":"A mapping of tag to replacement values for Tintin.","title":"tintinReplacements"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mudproto/xml.py def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mudproto/xml.py def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF )","title":"on_connectionMade()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mudproto/xml.py def on_dataReceived ( self , data : bytes ) -> None : appDataBuffer : bytearray = bytearray () while data : if self . state is XMLState . DATA : data = self . _handleXMLText ( data , appDataBuffer ) elif self . state is XMLState . TAG : data = self . _handleXMLTag ( data , appDataBuffer ) if appDataBuffer : if self . outputFormat == \"raw\" : super () . on_dataReceived ( bytes ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXMLBytes ( bytes ( appDataBuffer )))","title":"on_dataReceived()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.on_xmlEvent","text":"Called when an XML event was received. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mudproto/xml.py def on_xmlEvent ( self , name : str , data : bytes ) -> None : \"\"\" Called when an XML event was received. Args: name: The event name. data: The payload. \"\"\"","title":"on_xmlEvent()"},{"location":"api/xml/#mudproto.xml.XMLProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mudproto/xml.py def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/xml/#mudproto.xml.XMLState","text":"Valid states for the state machine. Source code in mudproto/xml.py class XMLState ( Enum ): \"\"\" Valid states for the state machine. \"\"\" DATA = auto () TAG = auto ()","title":"XMLState"}]}